<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>통계 분석 플랫폼 | 국립수산과학원</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Chart.js -->
    <script defer src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- SheetJS -->
    <script defer src="https://cdn.sheetjs.com/xlsx-0.19.3/package/dist/xlsx.full.min.js"></script>
    
    <!-- jsPDF for PDF export -->
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- html2canvas for PDF screenshots -->
    <script defer src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <style>
        @import url('https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css');
        
        * {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
        }
        
        /* Light Mode (Default) */
        :root {
            --bg-primary: #f8f9fa;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f1f5f9;
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --text-tertiary: #64748b;
            --border-color: #e0e0e0;
            --shadow-color: rgba(0, 0, 0, 0.08);
        }
        
        /* Dark Mode */
        [data-theme='dark'] {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-tertiary: #94a3b8;
            --border-color: #475569;
            --shadow-color: rgba(0, 0, 0, 0.3);
        }
        
        body {
            background: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        
        .professional-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            box-shadow: 0 2px 8px var(--shadow-color);
            transition: all 0.3s ease;
        }
        
        .professional-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
        }
        
        .step-number {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #3b82f6 0%, #6366f1 100%);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            transition: all 0.3s ease;
        }
        
        .step-number.inactive {
            background: #e5e7eb;
            color: #9ca3af;
        }
        
        .step-number.complete {
            background: #10b981;
            animation: checkmark 0.3s ease;
        }
        
        @keyframes checkmark {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .progress-bar {
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6 0%, #6366f1 100%);
            transition: width 0.5s ease;
        }
        
        .help-tooltip {
            background: #1e293b;
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            position: absolute;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
            max-width: 300px;
            opacity: 0;
            animation: fadeIn 0.3s forwards;
        }
        
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        
        .loading-spinner {
            border: 3px solid #e5e7eb;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* 공통 유틸리티 클래스들 */
        .info-box {
            padding: 16px;
            border-radius: 8px;
            border-width: 1px;
            animation: slideIn 0.3s ease;
        }
        
        .info-box.success {
            background: #f0f9ff;
            border-color: #bae6fd;
        }
        
        .info-box.warning {
            background: #fef3c7;
            border-color: #fde047;
        }
        
        .info-box.error {
            background: #fee2e2;
            border-color: #fca5a5;
        }
        
        .result-box {
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #bae6fd;
            background: #f0f9ff;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { 
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .warning-box {
            background: #fef3c7;
            border: 1px solid #fde68a;
            border-radius: 8px;
            padding: 16px;
        }
        
        .success-box {
            background: #d1fae5;
            border: 1px solid #a7f3d0;
            border-radius: 8px;
            padding: 16px;
        }
        
        .error-box {
            background: #fee2e2;
            border: 1px solid #fca5a5;
            border-radius: 8px;
            padding: 16px;
        }
        
        .auto-progress-checkbox {
            accent-color: #3b82f6;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #3b82f6 0%, #6366f1 100%);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
        
        .btn-primary::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        .btn-primary:hover::before {
            width: 300px;
            height: 300px;
        }
        
        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.25);
        }
        
        .btn-primary:disabled {
            background: #94a3b8;
            transform: none;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .btn-secondary {
            background: white;
            color: #475569;
            padding: 12px 24px;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .btn-secondary:hover {
            background: #f8fafc;
            border-color: #94a3b8;
            transform: translateY(-1px);
        }
        
        .info-badge {
            display: inline-flex;
            align-items: center;
            padding: 4px 12px;
            background: #eff6ff;
            color: #3730a3;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 500;
        }
        
        .drop-zone {
            border: 2px dashed #cbd5e1;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            background: #fafafa;
        }
        
        .drop-zone:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
        }
        
        .drop-zone.dragover {
            border-color: #3b82f6;
            background: #dbeafe;
            transform: scale(1.02);
        }
        
        .tooltip-trigger {
            display: inline-block;
            width: 16px;
            height: 16px;
            background: #e5e7eb;
            border-radius: 50%;
            text-align: center;
            line-height: 16px;
            font-size: 11px;
            cursor: help;
            margin-left: 4px;
        }
        
        .step-content {
            opacity: 0;
            animation: fadeSlideIn 0.4s forwards;
        }
        
        @keyframes fadeSlideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .pulse-once {
            animation: pulse 1s;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .loading-stage {
            display: flex;
            align-items: center;
            padding: 8px 0;
            opacity: 0.5;
            transition: opacity 0.3s;
        }
        
        .loading-stage.active {
            opacity: 1;
            font-weight: 600;
        }
        
        .loading-stage.complete {
            opacity: 0.7;
        }
        
        .loading-stage .check {
            display: none;
            color: #10b981;
            margin-right: 8px;
        }
        
        .loading-stage.complete .check {
            display: inline;
        }
        
        .loading-stage.complete .spinner {
            display: none;
        }
    </style>
</head>
<body>

    <!-- 첫 방문 안내 (옵션) -->
    <div id="welcomeTour" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
        <div class="bg-white rounded-lg p-8 max-w-md mx-4">
            <h2 class="text-xl font-bold mb-4">🎉 통계 분석 플랫폼에 오신 것을 환영합니다!</h2>
            <p class="text-gray-600 mb-6">
                이 플랫폼은 복잡한 통계 분석을 6단계로 간단하게 진행할 수 있도록 도와드립니다.
                통계 지식이 없어도 자동으로 최적의 분석 방법을 선택해드려요.
            </p>
            <div class="flex space-x-3">
                <button onclick="startTour()" class="btn-primary">
                    👋 간단한 투어 시작
                </button>
                <button onclick="closeTour()" class="btn-secondary">
                    나중에 하기
                </button>
            </div>
        </div>
    </div>

    <div class="min-h-screen p-4 md:p-8">
        <!-- 헤더 -->
        <header class="max-w-7xl mx-auto mb-8">
            <div class="professional-card p-6">
                <div class="flex justify-between items-center">
                    <div>
                        <h1 class="text-2xl font-bold text-gray-900">통계 분석 플랫폼</h1>
                        <p class="text-gray-600 mt-1">국립수산과학원 | National Institute of Fisheries Science</p>
                        <p class="text-xs text-gray-500 mt-1">SciPy.stats 기반 | Python 과학 컴퓨팅 라이브러리</p>
                    </div>
                    <div class="text-right">
                        <button onclick="showHelp()" class="btn-secondary mb-2">
                            <span class="mr-2">❓</span> 도움말
                        </button>

                        <button onclick="exportProgress()" class="btn-secondary mb-2 ml-2" id="exportBtn" style="display:none;">
                            <span class="mr-2">💾</span> 진행상황 저장
                        </button>
                    </div>
                </div>
                
                <!-- 개선된 로딩 상태 표시 -->
                <div class="mt-4 flex items-center justify-between">
                    <div id="pyodideStatus" class="bg-gray-50 rounded-lg p-4 flex-1">
                        <div class="text-center">
                            <div class="inline-block animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600 mr-2"></div>
                            <span class="text-sm text-gray-600">준비 중...</span>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <!-- 진행 단계 표시 (개선) -->
        <div class="max-w-7xl mx-auto mb-8">
            <div class="professional-card p-6">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-semibold">분석 진행 단계</h2>
                    <div class="flex items-center">
                        <button id="prevStepBtn" onclick="previousStep()" class="btn-secondary text-sm mr-2" disabled>
                            ← 이전 단계
                        </button>
                        <label class="flex items-center cursor-pointer">
                            <input type="checkbox" id="autoProgress" class="auto-progress-checkbox mr-2">
                            <span class="text-sm text-gray-600">자동 진행</span>
                            <span class="tooltip-trigger" onmouseover="showTooltip(event, '각 단계가 완료되면 자동으로 다음 단계로 진행합니다')" onmouseout="hideTooltip()">?</span>
                        </label>
                    </div>
                </div>
                
                <div class="flex items-center justify-between">
                    <!-- 단계 1: 데이터 입력 -->
                    <div class="text-center cursor-pointer" onclick="moveToStep(1)">
                        <div class="step-number" id="step1">1</div>
                        <p class="text-xs mt-2">데이터 입력</p>
                    </div>
                    
                    <div class="flex-1 h-1 bg-gray-300 mx-2"></div>
                    
                    <!-- 단계 2: 데이터 검증 -->
                    <div class="text-center cursor-pointer" onclick="moveToStep(2)">
                        <div class="step-number inactive" id="step2">2</div>
                        <p class="text-xs mt-2">데이터 검증</p>
                    </div>
                    
                    <div class="flex-1 h-1 bg-gray-300 mx-2"></div>
                    
                    <!-- 단계 3: 가정 검정 -->
                    <div class="text-center cursor-pointer" onclick="moveToStep(3)">
                        <div class="step-number inactive" id="step3">3</div>
                        <p class="text-xs mt-2">가정 검정</p>
                    </div>
                    
                    <div class="flex-1 h-1 bg-gray-300 mx-2"></div>
                    
                    <!-- 단계 4: 방법 선택 -->
                    <div class="text-center cursor-pointer" onclick="moveToStep(4)">
                        <div class="step-number inactive" id="step4">4</div>
                        <p class="text-xs mt-2">방법 선택</p>
                    </div>
                    
                    <div class="flex-1 h-1 bg-gray-300 mx-2"></div>
                    
                    <!-- 단계 5: 분석 실행 -->
                    <div class="text-center cursor-pointer" onclick="moveToStep(5)">
                        <div class="step-number inactive" id="step5">5</div>
                        <p class="text-xs mt-2">분석 실행</p>
                    </div>
                    
                    <div class="flex-1 h-1 bg-gray-300 mx-2"></div>
                    
                    <!-- 단계 6: 결과 해석 -->
                    <div class="text-center cursor-pointer" onclick="moveToStep(6)">
                        <div class="step-number inactive" id="step6">6</div>
                        <p class="text-xs mt-2">결과 해석</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- 단계별 콘텐츠 영역 (개선) -->
        <div class="max-w-7xl mx-auto">
            <!-- 단계 1: 데이터 입력 (개선) -->
            <div id="step1Content" class="professional-card p-6 step-content">
                <h3 class="text-xl font-bold mb-4">
                    1단계: 데이터 입력
                    <span class="tooltip-trigger" onmouseover="showTooltip(event, 'Excel, CSV 파일을 업로드하거나 샘플 데이터를 사용해보세요')" onmouseout="hideTooltip()">?</span>
                </h3>
                
                <!-- 드래그 앤 드롭 영역 개선 -->
                <div id="dropZone" class="drop-zone mb-4">
                    <svg class="mx-auto mb-4" width="64" height="64" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="8" y="8" width="48" height="48" rx="8" stroke-dasharray="4 4"/>
                        <path d="M32 24v16m-8-8h16" stroke-linecap="round"/>
                    </svg>
                    <p class="text-lg font-medium mb-2">파일을 여기로 드래그하거나 클릭하여 선택</p>
                    <p class="text-sm text-gray-500">Excel (.xlsx, .xls) 또는 CSV (.csv) 파일</p>
                    <p class="text-xs text-gray-400 mt-2">최대 파일 크기: 10MB</p>
                    <input type="file" id="fileInput" accept=".xlsx,.xls,.csv" class="hidden">
                </div>
                
                <!-- 파일 미리보기 -->
                <div id="filePreview" class="hidden mb-4">
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center">
                                <svg class="w-8 h-8 text-blue-600 mr-3" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z"/>
                                    <path fill-rule="evenodd" d="M4 5a2 2 0 012-2 1 1 0 000 2H6a2 2 0 00-2 2v6a2 2 0 002 2h8a2 2 0 002-2V7a2 2 0 00-2-2h-1a1 1 0 100-2h1a4 4 0 014 4v6a4 4 0 01-4 4H6a4 4 0 01-4-4V7a4 4 0 014-4z" clip-rule="evenodd"/>
                                </svg>
                                <div>
                                    <p class="font-medium" id="fileName">파일명.xlsx</p>
                                    <p class="text-sm text-gray-600" id="fileInfo">크기: 2.3MB | 행: 1,234 | 열: 5</p>
                                </div>
                            </div>
                            <button onclick="removeFile()" class="text-red-600 hover:text-red-800">
                                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- 데이터 업로드 후 설명 -->
                <div id="step1Explanation" class="hidden mt-4 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                    <h4 class="font-semibold text-blue-800 mb-2">📊 데이터 업로드 완료</h4>
                    <p class="text-sm text-gray-700 mb-2">
                        데이터가 성공적으로 업로드되었습니다. 이제 다음 단계에서 데이터의 품질을 검증하고 기본 정보를 확인할 예정입니다.
                    </p>
                    <ul class="text-xs text-gray-600 space-y-1 mb-3">
                        <li>• 데이터 형식 및 유형 검사</li>
                        <li>• 결측치 및 이상치 확인</li>
                        <li>• 변수별 기본 정보 요약</li>
                    </ul>
                    <div class="flex space-x-3">
                        <button onclick="proceedToStep2()" class="btn-primary" id="proceedBtn1">
                            데이터 검증 시작 →
                        </button>
                        <button onclick="clearFileSelection()" class="btn-secondary">
                            🔄 다른 파일 선택
                        </button>
                    </div>
                </div>
                
                <!-- 초기 업로드 버튼들 -->
                <div id="initialButtons" class="flex space-x-4">
                    <button onclick="generateSampleData()" class="btn-secondary">
                        <span class="mr-2">🎲</span> 샘플 데이터 생성
                    </button>
                </div>
            </div>

            <!-- 단계 2: 데이터 검증 -->
            <div id="step2Content" class="professional-card p-6 step-content hidden">
                <h3 class="text-xl font-bold mb-4">
                    2단계: 데이터 검증
                    <span class="tooltip-trigger" onmouseover="showTooltip(event, '업로드된 데이터의 유효성을 검사합니다')" onmouseout="hideTooltip()">?</span>
                </h3>
                
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div class="bg-blue-50 p-4 rounded-lg">
                        <p class="text-sm font-semibold mb-2">데이터 요약</p>
                        <div class="text-xs space-y-1">
                            <p>행: <span id="rowCount">0</span></p>
                            <p>열: <span id="colCount">0</span></p>
                        </div>
                        <!-- 데이터 테이블은 여기로 이동 -->
                        <div class="mt-3 overflow-x-auto max-h-32">
                            <table class="min-w-full text-xs">
                                <thead id="tableHeader"></thead>
                                <tbody id="tableBody"></tbody>
                            </table>
                        </div>
                    </div>
                    <div class="bg-green-50 p-4 rounded-lg">
                        <p class="text-sm font-semibold">검증 상태</p>
                        <div id="dataValidation" class="mt-2"></div>
                    </div>
                </div>
                
                <!-- 상세 검증 결과 -->
                <div id="step2DetailedResults" class="hidden mt-4 p-4 bg-gray-50 rounded-lg">
                    <h4 class="font-medium mb-3">📊 상세 분석 결과</h4>
                    <div id="detailedValidationContent"></div>
                </div>
                
                <!-- 다음 단계 진행 버튼 -->
                <div id="step2NextButton" class="hidden mt-4 text-center">
                    <button onclick="proceedToStep3()" class="btn-primary" disabled>
                        통계적 가정 검정 시작 →
                    </button>
                </div>
                
                <!-- 데이터 검증 결과 설명 -->
                <div id="step2Explanation" class="hidden mt-4 p-4 bg-green-50 border border-green-200 rounded-lg">
                    <h4 class="font-semibold text-green-800 mb-2">✅ 데이터 검증 완료</h4>
                    <p class="text-sm text-gray-700 mb-2">
                        데이터 품질 검증이 완료되었습니다. 변수 타입이 분류되고 분석 추천사항이 제시되었습니다. 다음 단계에서는 선택한 분석에 필요한 통계적 가정을 검정하겠습니다.
                    </p>
                    <div class="grid grid-cols-2 gap-2 mb-3">
                        <div class="text-xs">
                            <strong>수행된 검증:</strong>
                            <ul class="text-gray-600 mt-1 space-y-1">
                                <li>• 결측치 및 데이터 품질 확인</li>
                                <li>• 변수 타입 분류 (연속형/그룹형)</li>
                                <li>• 이상치 감지 및 그룹 균형 확인</li>
                            </ul>
                        </div>
                        <div class="text-xs">
                            <strong>다음 단계 예정:</strong>
                            <ul class="text-gray-600 mt-1 space-y-1">
                                <li>• 정규성 검정 (Shapiro-Wilk/KS)</li>
                                <li>• 등분산성 검정 (Levene/Bartlett)</li>
                                <li>• 통계방법 자동 추천</li>
                            </ul>
                        </div>
                    </div>
                    <div class="flex space-x-3">
                        <button onclick="proceedToStep3()" class="btn-primary">
                            가정 검사 시작 →
                        </button>
                        <button onclick="revalidateData()" class="btn-secondary">
                            🔄 데이터 재검증
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- 단계 3: 통계적 가정 검정 -->
            <div id="step3Content" class="professional-card p-6 step-content hidden">
                <h3 class="text-xl font-bold mb-4">
                    3단계: 통계적 가정 검정
                    <span class="tooltip-trigger" onmouseover="showTooltip(event, '정규성과 등분산성을 검정합니다')" onmouseout="hideTooltip()">?</span>
                </h3>
                
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <h4 class="font-semibold mb-2">정규성 검정</h4>
                        <div id="normalityResults"></div>
                    </div>
                    <div>
                        <h4 class="font-semibold mb-2">등분산성 검정</h4>
                        <div id="homogeneityResults"></div>
                    </div>
                </div>
                
                <!-- 가정 검사 결과 설명 -->
                <div id="step3Explanation" class="hidden mt-4 p-4 bg-purple-50 border border-purple-200 rounded-lg">
                    <h4 class="font-semibold text-purple-800 mb-2">🔍 가정 검사 완료</h4>
                    <p class="text-sm text-gray-700 mb-2">
                        통계 분석을 위한 기본 가정 검사가 완료되었습니다. 이제 데이터의 특성에 기반하여 최적의 통계 방법을 추천해드리겠습니다.
                    </p>
                    <div class="bg-white p-3 rounded border mb-3">
                        <p class="text-xs font-semibold text-purple-700 mb-1">검사 결과 해석:</p>
                        <div id="assumptionInterpretation" class="text-xs text-gray-600">
                            <!-- 가정 검사 결과가 여기에 표시됩니다 -->
                        </div>
                    </div>
                    <div class="flex space-x-3">
                        <button onclick="proceedToStep4()" class="btn-primary">
                            최적 방법 추천 →
                        </button>
                        <button onclick="retestAssumptions()" class="btn-secondary">
                            🔄 가정 재검사
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- 단계 4: 통계 방법 선택 -->
            <div id="step4Content" class="professional-card p-6 step-content hidden">
                <h3 class="text-xl font-bold mb-4">
                    4단계: 최적 통계 방법 선택
                    <span class="tooltip-trigger" onmouseover="showTooltip(event, '데이터 특성에 맞는 최적의 통계 방법을 추천합니다')" onmouseout="hideTooltip()">?</span>
                </h3>
                
                <div id="methodRecommendation" class="bg-blue-50 p-6 rounded-lg">
                    <p class="text-lg font-semibold mb-2">추천 방법 분석 중...</p>
                </div>
                
                <!-- 방법 추천 결과 설명 -->
                <div id="step4Explanation" class="hidden mt-4 p-4 bg-orange-50 border border-orange-200 rounded-lg">
                    <h4 class="font-semibold text-orange-800 mb-2">🎯 최적 방법 결정</h4>
                    <p class="text-sm text-gray-700 mb-2">
                        데이터 특성을 분석하여 최적의 통계 방법을 결정했습니다. 아래 추천 내용을 확인하시고 분석을 실행해주세요.
                    </p>
                    <div class="bg-white p-3 rounded border mb-3">
                        <div id="methodDetails">
                            <!-- 추천 방법 상세 정보가 여기에 표시됩니다 -->
                        </div>
                    </div>
                    <div class="flex space-x-3">
                        <button onclick="proceedToStep5()" class="btn-primary">
                            분석 실행 시작 →
                        </button>
                        <button onclick="moveToStep(3)" class="btn-secondary">
                            ← 가정 검사 재확인
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- 단계 5: 통계 분석 실행 -->
            <div id="step5Content" class="professional-card p-6 step-content hidden">
                <h3 class="text-xl font-bold mb-4">
                    5단계: 통계 분석 실행
                    <span class="tooltip-trigger" onmouseover="showTooltip(event, 'SciPy.stats를 사용하여 통계 분석을 수행합니다')" onmouseout="hideTooltip()">?</span>
                </h3>
                
                <div class="text-center py-12">
                    <div class="loading-spinner mx-auto mb-4" style="width: 40px; height: 40px;"></div>
                    <p class="text-lg font-medium">분석을 실행하고 있습니다...</p>
                    <p class="text-sm text-gray-600 mt-2" id="analysisProgress">데이터 처리 중...</p>
                </div>
            </div>
            
            <!-- 단계 6: 결과 해석 -->
            <div id="step6Content" class="professional-card p-6 step-content hidden">
                <h3 class="text-xl font-bold mb-4">
                    6단계: 결과 해석
                    <span class="tooltip-trigger" onmouseover="showTooltip(event, '분석 결과를 이해하기 쉽게 해석해드립니다')" onmouseout="hideTooltip()">?</span>
                </h3>
                
                <div id="analysisResults">
                    <!-- 결과가 여기에 표시됩니다 -->
                </div>
                
                <!-- 분석 결과 설명 -->
                <div id="step6Explanation" class="mt-4 p-4 bg-green-50 border border-green-200 rounded-lg">
                    <h4 class="font-semibold text-green-800 mb-2">🎆 분석 완료</h4>
                    <p class="text-sm text-gray-700 mb-2">
                        통계 분석이 성공적으로 완료되었습니다. 위의 결과를 통해 데이터에서 의미 있는 패턴을 파악할 수 있습니다.
                    </p>
                    <div class="grid grid-cols-2 gap-2 mb-3">
                        <div class="text-xs">
                            <strong>결과 활용:</strong>
                            <ul class="text-gray-600 mt-1 space-y-1">
                                <li>• 연구 및 보고서 작성</li>
                                <li>• 의사결정 근거 자료</li>
                            </ul>
                        </div>
                        <div class="text-xs">
                            <strong>내보내기 옵션:</strong>
                            <ul class="text-gray-600 mt-1 space-y-1">
                                <li>• Excel 파일로 저장</li>
                                <li>• PDF 보고서 생성</li>
                            </ul>
                        </div>
                    </div>
                    <div class="flex space-x-3">
                        <button onclick="exportResults()" class="btn-primary">
                            📥 결과 내보내기
                        </button>
                        <button onclick="resetAnalysis()" class="btn-secondary">
                            🔄 새로운 분석
                        </button>
                        <button onclick="moveToStep(1)" class="btn-secondary">
                            ← 처음으로
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- 나머지 단계들은 기존과 유사하게 개선 -->
        </div>
    </div>

    <!-- 툴팁 컨테이너 -->
    <div id="tooltip" class="help-tooltip hidden"></div>

    <!-- 개선된 Footer -->
    <footer class="mt-12 py-6 bg-gray-100 border-t border-gray-200">
        <div class="max-w-6xl mx-auto px-4">
            <div class="text-center">
                <p class="text-xs text-gray-600 mb-2">
                    <strong>통계 분석 엔진:</strong> SciPy.stats v1.11+ | NumPy v1.24+ | Pyodide v0.24.1
                </p>
                <p class="text-xs text-gray-500">
                    이 플랫폼은 오픈소스 과학 컴퓨팅 라이브러리 SciPy의 검증된 통계 알고리즘을 사용합니다.<br>
                    모든 통계 계산은 SciPy.stats 모듈의 표준 구현을 따르며, 학술 연구에서 널리 사용되는 신뢰할 수 있는 방법론을 적용합니다.
                </p>
                
                <!-- 다크 모드 토글 버튼 -->
                <div class="mt-4 mb-2">
                    <button id="darkModeToggle" class="inline-flex items-center px-3 py-2 rounded-lg bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors text-sm" title="다크 모드 전환">
                        <svg id="sunIcon" class="w-4 h-4 text-yellow-500 hidden mr-2" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" clip-rule="evenodd"/>
                        </svg>
                        <svg id="moonIcon" class="w-4 h-4 text-gray-700 dark:text-gray-200 mr-2" fill="currentColor" viewBox="0 0 20 20">
                            <path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"/>
                        </svg>
                        <span class="text-gray-700 dark:text-gray-200">다크 모드</span>
                    </button>
                </div>
                
                <p class="text-xs text-gray-400 mt-2">
                    © 2024 국립수산과학원 통계 분석 플랫폼 | BSD 라이선스 기반 오픈소스 활용
                </p>
            </div>
        </div>
    </footer>

    <!-- Pyodide Script -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    
    <script>
        // 전역 변수
        let pyodide = null;
        let currentStep = 1;
        let autoProgress = false;
        let currentData = null;
        let analysisResults = {};
        let tourStep = 0;
        
        // 첫 방문 체크
        if (!localStorage.getItem('hasVisited')) {
            setTimeout(() => {
                document.getElementById('welcomeTour').classList.remove('hidden');
                localStorage.setItem('hasVisited', 'true');
            }, 1000);
        }
        
        // 투어 기능
        // DOM 조작 유틸리티 함수들
        function showElement(elementId) {
            const element = document.getElementById(elementId);
            if (element) element.classList.remove('hidden');
        }
        
        function hideElement(elementId) {
            const element = document.getElementById(elementId);
            if (element) element.classList.add('hidden');
        }
        
        function enableButton(selector) {
            const button = document.querySelector(selector);
            if (button) {
                button.disabled = false;
                button.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }
        
        function disableButton(selector) {
            const button = document.querySelector(selector);
            if (button) {
                button.disabled = true;
                button.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }
        
        // 툴팁 표시
        function showTooltip(event, text) {
            const tooltip = document.getElementById('tooltip');
            tooltip.textContent = text;
            tooltip.style.left = event.clientX + 10 + 'px';
            tooltip.style.top = event.clientY - 30 + 'px';
            tooltip.classList.remove('hidden');
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').classList.add('hidden');
        }
        
        // 메모리 관리 함수
        function cleanupPyodideMemory() {
            if (window.pyodide) {
                try {
                    pyodide.runPython(`
                        import gc
                        gc.collect()
                    `);
                    console.log('Python 가비지 컬렉션 실행됨');
                } catch (error) {
                    console.error('메모리 정리 실패:', error);
                }
            }
        }
        
        // 주기적인 메모리 정리 (5분마다)
        setInterval(cleanupPyodideMemory, 5 * 60 * 1000);
        
        // 간소화된 Pyodide 초기화
        async function initPyodide() {
            try {
                pyodide = await loadPyodide({
                    indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"
                });
                
                // 메모리 부족 체크
                if (performance && performance.memory) {
                    const memoryInfo = performance.memory;
                    if (memoryInfo.usedJSHeapSize / memoryInfo.jsHeapSizeLimit > 0.9) {
                        throw new Error('메모리 부족: 브라우저를 재시작하거나 다른 탭을 닫아주세요.');
                    }
                }
                
                await pyodide.loadPackage(['numpy', 'scipy']);
                await pyodide.runPythonAsync(`
                    import numpy as np
                    from scipy import stats
                    import json
                    import warnings
                    warnings.filterwarnings('ignore')
                    
                    # 정규성 검정 함수
                    def test_normality(values):
                        """정규성 검정 (Shapiro-Wilk or D'Agostino K²)"""
                        x = np.array(values, dtype=float)
                        # NaN 제거
                        x = x[~np.isnan(x)]
                        n = len(x)
                        
                        if n < 3:
                            return {
                                "test": "insufficient_data",
                                "n": n,
                                "statistic": None,
                                "pValue": None,
                                "isNormal": False,
                                "message": "표본 수 부족 (n < 3)"
                            }
                        elif n < 50:
                            # Shapiro-Wilk test
                            stat, p = stats.shapiro(x)
                            test_name = "Shapiro-Wilk"
                        else:
                            # D'Agostino K² test (더 안정적)
                            stat, p = stats.normaltest(x)
                            test_name = "D'Agostino K²"
                        
                        # 왜도와 첨도 계산
                        skewness = stats.skew(x)
                        kurtosis = stats.kurtosis(x)
                        
                        return {
                            "test": test_name,
                            "n": n,
                            "statistic": float(stat),
                            "pValue": float(p),
                            "isNormal": p > 0.05,
                            "skewness": float(skewness),
                            "kurtosis": float(kurtosis),
                            "mean": float(np.mean(x)),
                            "std": float(np.std(x, ddof=1))
                        }
                    
                    # 등분산성 검정 함수
                    def test_homogeneity(groups_dict):
                        """등분산성 검정 (Brown-Forsythe/Levene)"""
                        # 그룹별 데이터 준비
                        groups = []
                        group_names = []
                        for name, values in groups_dict.items():
                            arr = np.array(values, dtype=float)
                            arr = arr[~np.isnan(arr)]
                            if len(arr) >= 2:
                                groups.append(arr)
                                group_names.append(name)
                        
                        if len(groups) < 2:
                            return {
                                "test": "insufficient_groups",
                                "statistic": None,
                                "pValue": None,
                                "isHomogeneous": False,
                                "message": "비교 가능한 그룹이 2개 미만"
                            }
                        
                        # Brown-Forsythe test (중앙값 기반 - 더 robust)
                        stat_bf, p_bf = stats.levene(*groups, center='median')
                        
                        # Levene test (평균 기반 - 참고용)
                        stat_lv, p_lv = stats.levene(*groups, center='mean')
                        
                        # Bartlett test (정규성 충족 시 사용)
                        try:
                            stat_bt, p_bt = stats.bartlett(*groups)
                        except:
                            stat_bt, p_bt = None, None
                        
                        # 각 그룹의 분산
                        variances = [float(np.var(g, ddof=1)) for g in groups]
                        
                        return {
                            "test": "Brown-Forsythe",
                            "statistic": float(stat_bf),
                            "pValue": float(p_bf),
                            "isHomogeneous": p_bf > 0.05,
                            "levene_mean": {"statistic": float(stat_lv), "pValue": float(p_lv)},
                            "bartlett": {"statistic": float(stat_bt) if stat_bt else None, 
                                        "pValue": float(p_bt) if p_bt else None},
                            "variances": variances,
                            "variance_ratio": max(variances) / min(variances) if min(variances) > 0 else None,
                            "groups": len(groups)
                        }
                    
                    # t-test 함수
                    def perform_ttest(group1, group2, equal_var=True):
                        """Independent t-test or Welch's t-test"""
                        x = np.array(group1, dtype=float)
                        y = np.array(group2, dtype=float)
                        x = x[~np.isnan(x)]
                        y = y[~np.isnan(y)]
                        
                        if len(x) < 2 or len(y) < 2:
                            return {"error": "표본 수 부족"}
                        
                        # t-test
                        stat, p = stats.ttest_ind(x, y, equal_var=equal_var)
                        
                        # 효과 크기 (Cohen's d)
                        nx, ny = len(x), len(y)
                        mx, my = np.mean(x), np.mean(y)
                        vx, vy = np.var(x, ddof=1), np.var(y, ddof=1)
                        
                        # Pooled standard deviation
                        sp = np.sqrt(((nx - 1) * vx + (ny - 1) * vy) / (nx + ny - 2))
                        cohens_d = (mx - my) / sp if sp > 0 else 0
                        
                        # 95% CI for mean difference
                        se = sp * np.sqrt(1/nx + 1/ny)
                        t_critical = stats.t.ppf(0.975, nx + ny - 2)
                        ci_lower = (mx - my) - t_critical * se
                        ci_upper = (mx - my) + t_critical * se
                        
                        return {
                            "statistic": float(stat),
                            "pValue": float(p),
                            "df": nx + ny - 2,
                            "cohens_d": float(cohens_d),
                            "mean_diff": float(mx - my),
                            "ci_95": [float(ci_lower), float(ci_upper)],
                            "group1": {"mean": float(mx), "std": float(np.sqrt(vx)), "n": nx},
                            "group2": {"mean": float(my), "std": float(np.sqrt(vy)), "n": ny}
                        }
                    
                    # ANOVA 함수
                    def perform_anova(groups_dict):
                        """One-way ANOVA"""
                        groups = []
                        for name, values in groups_dict.items():
                            arr = np.array(values, dtype=float)
                            arr = arr[~np.isnan(arr)]
                            if len(arr) >= 2:
                                groups.append(arr)
                        
                        if len(groups) < 2:
                            return {"error": "그룹 수 부족"}
                        
                        # ANOVA
                        stat, p = stats.f_oneway(*groups)
                        
                        # 효과 크기 계산
                        all_data = np.concatenate(groups)
                        grand_mean = np.mean(all_data)
                        
                        # SST, SSB, SSW
                        sst = np.sum((all_data - grand_mean) ** 2)
                        ssb = sum(len(g) * (np.mean(g) - grand_mean) ** 2 for g in groups)
                        ssw = sst - ssb
                        
                        # eta squared
                        eta_squared = ssb / sst if sst > 0 else 0
                        
                        # omega squared
                        df_between = len(groups) - 1
                        df_within = len(all_data) - len(groups)
                        ms_between = ssb / df_between if df_between > 0 else 0
                        ms_within = ssw / df_within if df_within > 0 else 0
                        
                        omega_squared = (ssb - df_between * ms_within) / (sst + ms_within) if (sst + ms_within) > 0 else 0
                        
                        return {
                            "statistic": float(stat),
                            "pValue": float(p),
                            "df_between": df_between,
                            "df_within": df_within,
                            "eta_squared": float(eta_squared),
                            "omega_squared": float(omega_squared),
                            "group_count": len(groups),
                            "total_n": len(all_data)
                        }
                    
                    # 비모수 검정 함수들
                    def perform_mann_whitney(group1, group2):
                        """Mann-Whitney U test"""
                        x = np.array(group1, dtype=float)
                        y = np.array(group2, dtype=float)
                        x = x[~np.isnan(x)]
                        y = y[~np.isnan(y)]
                        
                        if len(x) < 2 or len(y) < 2:
                            return {"error": "표본 수 부족"}
                        
                        stat, p = stats.mannwhitneyu(x, y, alternative='two-sided')
                        
                        # 효과 크기 (rank-biserial correlation)
                        n1, n2 = len(x), len(y)
                        r = 1 - (2 * stat) / (n1 * n2)
                        
                        return {
                            "statistic": float(stat),
                            "pValue": float(p),
                            "effect_size": float(r),
                            "n1": n1,
                            "n2": n2
                        }
                    
                    def perform_kruskal_wallis(groups_dict):
                        """Kruskal-Wallis H test"""
                        groups = []
                        for name, values in groups_dict.items():
                            arr = np.array(values, dtype=float)
                            arr = arr[~np.isnan(arr)]
                            if len(arr) >= 2:
                                groups.append(arr)
                        
                        if len(groups) < 2:
                            return {"error": "그룹 수 부족"}
                        
                        stat, p = stats.kruskal(*groups)
                        
                        # 효과 크기 (epsilon squared)
                        n = sum(len(g) for g in groups)
                        k = len(groups)
                        epsilon_squared = (stat - k + 1) / (n - k) if (n - k) > 0 else 0
                        
                        return {
                            "statistic": float(stat),
                            "pValue": float(p),
                            "epsilon_squared": float(epsilon_squared),
                            "group_count": k,
                            "total_n": n
                        }
                    
                    # 통계 분석 함수들
                    def validate_data(data):
                        """데이터 검증"""
                        issues = []
                        valid = True
                        
                        for col, values in data.items():
                            # 결측치 확인
                            null_count = sum(1 for v in values if v is None or (isinstance(v, str) and v.strip() == ''))
                            if null_count > 0:
                                issues.append(f"{col}: {null_count}개 결측치 발견")
                            
                            # 숫자 데이터 확인
                            numeric_values = []
                            for v in values:
                                if v is not None and str(v).strip() != '':
                                    try:
                                        numeric_values.append(float(v))
                                    except:
                                        pass
                            
                            if len(numeric_values) < len(values) * 0.5:
                                issues.append(f"{col}: 숫자가 아닌 데이터가 50% 이상")
                                valid = False
                        
                        return {
                            'valid': valid,
                            'issues': issues
                        }
                    
                    print("통계 엔진 준비 완료")
                `);
                
                // 완료 즉시 사용 가능하게
                document.getElementById('pyodideStatus').innerHTML = `
                    <div class="text-center">
                        <span class="text-sm text-green-600">✓ 준비 완료</span>
                    </div>
                `;
                document.getElementById('proceedBtn1').disabled = false;
                
                // 3초 후 로딩 상태 영역 숨기기
                setTimeout(() => {
                    const pyodideStatus = document.getElementById('pyodideStatus');
                    if (pyodideStatus) {
                        pyodideStatus.style.transition = 'opacity 0.5s ease';
                        pyodideStatus.style.opacity = '0';
                        setTimeout(() => {
                            pyodideStatus.style.display = 'none';
                        }, 500);
                    }
                }, 3000);
                
            } catch (error) {
                console.error("Pyodide 초기화 실패:", error);
                
                // 에러 타입별 처리
                let errorMessage = '알 수 없는 오류가 발생했습니다.';
                let solution = '페이지를 새로고침 해주세요.';
                
                if (error.name === 'NetworkError' || error.message.includes('fetch')) {
                    errorMessage = '네트워크 연결에 문제가 있습니다.';
                    solution = '인터넷 연결을 확인하고 다시 시도해주세요.';
                } else if (error.message.includes('메모리')) {
                    errorMessage = error.message;
                    solution = '브라우저를 재시작하거나 다른 탭을 닫아주세요.';
                } else if (error.message.includes('WebAssembly')) {
                    errorMessage = '브라우저가 WebAssembly를 지원하지 않습니다.';
                    solution = '최신 버전의 Chrome, Firefox, 또는 Edge를 사용해주세요.';
                }
                
                const statusDiv = document.getElementById('pyodideStatus');
                statusDiv.textContent = '';
                const errorBox = document.createElement('div');
                errorBox.className = 'error-box';
                errorBox.innerHTML = `
                    <p class="font-semibold mb-2">⚠️ 통계 엔진 로딩 실패</p>
                    <p class="text-sm text-gray-700 mb-1">${errorMessage}</p>
                    <p class="text-sm text-gray-600 mb-3">${solution}</p>
                    <div class="flex space-x-2">
                        <button onclick="location.reload()" class="btn-primary text-sm">
                            🔄 새로고침하여 다시 시도
                            </button>
                            <button onclick="showOfflineHelp()" class="btn-secondary text-sm">
                                📖 오프라인 모드 안내
                            </button>
                        </div>
                    </div>
                `;
            }
        }
        
        // 드래그 앤 드롭 이벤트
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        
        dropZone?.addEventListener('click', () => fileInput.click());
        
        dropZone?.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });
        
        dropZone?.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });
        
        dropZone?.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });
        
        fileInput?.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });
        
        // 파일 크기 포맷팅 함수
        function formatFileSize(bytes) {
            if (bytes < 1024) return `${bytes} bytes`;
            if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
            return `${(bytes / 1024 / 1024).toFixed(2)} MB`;
        }
        
        // 파일 처리
        function handleFile(file) {
            // 파일 크기 체크
            if (file.size > 10 * 1024 * 1024) {
                alert('파일 크기는 10MB를 초과할 수 없습니다.');
                return;
            }
            
            // 파일 미리보기 표시
            document.getElementById('dropZone').classList.add('hidden');
            document.getElementById('filePreview').classList.remove('hidden');
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileInfo').textContent = `크기: ${formatFileSize(file.size)} | 처리 중...`;
            
            // 파일 읽기
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    // 파일 파싱 로직
                    let parsedData;
                    
                    if (file.name.endsWith('.csv')) {
                        // CSV 파싱
                        const text = e.target.result;
                        const lines = text.split('\n').filter(line => line.trim());
                        if (lines.length < 2) throw new Error('CSV 파일이 비어있거나 헤더만 있습니다.');
                        
                        const headers = lines[0].split(',').map(h => h.trim());
                        const data = {};
                        headers.forEach(header => data[header] = []);
                        
                        for (let i = 1; i < lines.length; i++) {
                            const values = lines[i].split(',').map(v => v.trim());
                            headers.forEach((header, idx) => {
                                if (values[idx] !== undefined) {
                                    data[header].push(values[idx]);
                                }
                            });
                        }
                        parsedData = data;
                    } else if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                        // Excel 파싱 (XLSX 라이브러리 사용)
                        const workbook = XLSX.read(e.target.result, { type: 'array' });
                        const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                        const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
                        
                        if (jsonData.length < 2) throw new Error('Excel 파일이 비어있거나 헤더만 있습니다.');
                        
                        const headers = jsonData[0];
                        const data = {};
                        headers.forEach(header => data[header] = []);
                        
                        for (let i = 1; i < jsonData.length; i++) {
                            headers.forEach((header, idx) => {
                                if (jsonData[i][idx] !== undefined) {
                                    data[header].push(jsonData[i][idx]);
                                }
                            });
                        }
                        parsedData = data;
                    } else {
                        throw new Error('지원되지 않는 파일 형식입니다.');
                    }
                    
                    currentData = parsedData;
                    const rowCount = Object.values(parsedData)[0]?.length || 0;
                    document.getElementById('fileInfo').textContent = `크기: ${formatFileSize(file.size)} | ${Object.keys(parsedData).length}개 열, ${rowCount}개 행`;
                    
                    // 설명 박스 표시
                    document.getElementById('initialButtons').classList.add('hidden');
                    document.getElementById('step1Explanation').classList.remove('hidden');
                    
                    // 다음 단계 버튼 활성화
                    document.getElementById('proceedBtn1').disabled = false;
                    
                    // 자동 진행
                    if (autoProgress) {
                        setTimeout(() => proceedToStep2(), 1000);
                    }
                } catch (error) {
                    alert('파일 읽기 중 오류가 발생했습니다: ' + error.message);
                    removeFile();
                }
            };
            
            if (file.name.endsWith('.csv')) {
                reader.readAsText(file);
            } else {
                reader.readAsArrayBuffer(file);
            }
        }
        
        // 파일 제거
        // 파일 제거 (통합된 함수)
        function removeFile(resetToStart = false) {
            // 기본 파일 제거
            document.getElementById('dropZone').classList.remove('hidden');
            document.getElementById('filePreview').classList.add('hidden');
            document.getElementById('fileInput').value = '';
            currentData = null;
            document.getElementById('proceedBtn1').disabled = true;
            
            // 완전 초기화 옵션
            if (resetToStart) {
                analysisResults = {};
                document.getElementById('step1Explanation').classList.add('hidden');
                document.getElementById('initialButtons').classList.remove('hidden');
                moveToStep(1);
            }
        }
        
        // 다른 파일 선택을 위한 wrapper
        function clearFileSelection() {
            removeFile(true);
        }
        
        // 이전 단계로 이동
        function previousStep() {
            if (currentStep > 1) {
                moveToStep(currentStep - 1);
            }
        }
        
        // 단계 이동 (개선)
        function moveToStep(step, isForwardProgress = false) {
            // 현재 단계 숨기기
            const currentContent = document.getElementById(`step${currentStep}Content`);
            if (currentContent) {
                currentContent.classList.add('hidden');
            }
            
            // 새 단계 표시
            const newContent = document.getElementById(`step${step}Content`);
            if (newContent) {
                newContent.classList.remove('hidden');
                newContent.classList.add('pulse-once');
                setTimeout(() => newContent.classList.remove('pulse-once'), 1000);
            }
            
            // 단계 번호 업데이트
            for (let i = 1; i <= 6; i++) {
                const stepEl = document.getElementById(`step${i}`);
                if (!stepEl) continue;
                
                if (i < step) {
                    stepEl.classList.add('complete');
                    stepEl.classList.remove('inactive');
                } else if (i === step) {
                    stepEl.classList.remove('complete', 'inactive');
                } else {
                    stepEl.classList.add('inactive');
                    stepEl.classList.remove('complete');
                }
            }
            
            const previousStep = currentStep;
            currentStep = step;
            
            // 이전 버튼 활성화/비활성화
            const prevBtn = document.getElementById('prevStepBtn');
            if (prevBtn) {
                prevBtn.disabled = step === 1;
            }
            
            // 진행률 업데이트
            const progress = ((step - 1) / 5) * 100;
            const progressBar = document.getElementById('progressBar');
            if (progressBar) {
                progressBar.style.width = progress + '%';
            }
            
            // 앞으로 진행할 때만 데이터 처리 (뒤로 갈 때는 기존 결과 표시)
            if (!isForwardProgress) {
                // 이전 단계로 돌아갈 때 - 저장된 결과가 있으면 표시
                if (step === 2 && analysisResults.validation) {
                    displayValidationResults(analysisResults.validation);
                } else if (step === 3 && analysisResults.assumptions) {
                    displayAssumptionResults(analysisResults.assumptions);
                } else if (step === 4 && analysisResults.method) {
                    displayMethodRecommendation(analysisResults.method);
                } else if (step === 5 && analysisResults.analysis) {
                    displayAnalysisProgress(analysisResults.analysis);
                } else if (step === 6 && analysisResults.final) {
                    displayResults();
                }
            }
        }
        

        
        // 샘플 데이터 생성
        function generateSampleData() {
            currentData = {
                '그룹A': [23, 25, 27, 22, 24, 26, 28, 25, 24, 23],
                '그룹B': [31, 33, 35, 32, 34, 36, 38, 35, 34, 33],
                '그룹C': [42, 44, 46, 43, 45, 47, 49, 46, 45, 44]
            };
            
            // 미리보기 표시
            document.getElementById('dropZone').classList.add('hidden');
            document.getElementById('filePreview').classList.remove('hidden');
            document.getElementById('fileName').textContent = '샘플 데이터';
            document.getElementById('fileInfo').textContent = '3개 그룹 | 각 10개 관측치';
            
            // 설명 박스 표시
            document.getElementById('initialButtons').classList.add('hidden');
            document.getElementById('step1Explanation').classList.remove('hidden');
            
            // 성공 메시지
            const successMsg = document.createElement('div');
            successMsg.className = 'success-box mt-4';
            successMsg.innerHTML = '✅ 샘플 데이터가 생성되었습니다!';
            document.getElementById('step1Content').appendChild(successMsg);
            
            setTimeout(() => successMsg.remove(), 3000);
        }
        
        // 오프라인 도움말
        function showOfflineHelp() {
            alert('오프라인 모드에서는 사전에 다운로드한 파일을 사용해주세요.\n자세한 내용은 도움말을 참조하세요.');
        }
        
        // 도움말 표시 (개선)
        function showHelp() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center';
            modal.innerHTML = `
                <div class="bg-white rounded-lg p-8 max-w-2xl mx-4 max-h-[80vh] overflow-y-auto">
                    <h2 class="text-2xl font-bold mb-4">📖 사용 가이드</h2>
                    
                    <div class="space-y-4 text-sm">
                        <div class="border-l-4 border-blue-500 pl-4">
                            <h3 class="font-semibold text-blue-700 mb-2">🚀 시작하기</h3>
                            <p>1. <strong>데이터 업로드</strong>: CSV 또는 Excel 파일을 업로드하거나 샘플 데이터를 사용하세요.</p>
                            <p>2. <strong>데이터 검증</strong>: 업로드된 데이터의 품질을 자동으로 검사합니다.</p>
                            <p>3. <strong>분석 실행</strong>: 데이터 특성에 맞는 통계 분석을 추천받고 실행합니다.</p>
                        </div>
                        
                        <div class="border-l-4 border-green-500 pl-4">
                            <h3 class="font-semibold text-green-700 mb-2">📊 지원하는 분석</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li><strong>t-검정</strong>: 두 그룹 간 평균 차이 비교</li>
                                <li><strong>분산분석(ANOVA)</strong>: 세 개 이상 그룹 간 차이 비교</li>
                                <li><strong>상관분석</strong>: 변수 간 관계 분석</li>
                                <li><strong>기술통계</strong>: 평균, 표준편차 등 기본 통계</li>
                            </ul>
                        </div>
                        
                        <div class="border-l-4 border-orange-500 pl-4">
                            <h3 class="font-semibold text-orange-700 mb-2">💡 팁</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li>데이터 첫 번째 행은 <strong>변수명(헤더)</strong>으로 사용됩니다</li>
                                <li><strong>숫자 데이터</strong>는 연속형 변수로, <strong>텍스트 데이터</strong>는 그룹 변수로 분류됩니다</li>
                                <li>결측치가 많으면 분석 정확도가 낮아질 수 있습니다</li>
                                <li>자동 진행 모드를 체크하면 단계별로 자동 진행됩니다</li>
                            </ul>
                        </div>
                        
                        <div class="border-l-4 border-red-500 pl-4">
                            <h3 class="font-semibold text-red-700 mb-2">⚠️ 주의사항</h3>
                            <ul class="list-disc list-inside space-y-1">
                                <li>파일 크기는 <strong>10MB 이하</strong>로 제한됩니다</li>
                                <li>처음 로딩 시 통계 엔진 초기화에 <strong>30초~1분</strong> 소요됩니다</li>
                                <li>브라우저를 새로고침하면 모든 데이터가 초기화됩니다</li>
                            </ul>
                        </div>
                    </div>
                    
                    <button onclick="this.parentElement.parentElement.remove()" class="btn-primary mt-6 w-full">
                        확인
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        // 초기화
        document.addEventListener('DOMContentLoaded', () => {
            initPyodide();
            
            // 자동 진행 체크박스
            document.getElementById('autoProgress').addEventListener('change', (e) => {
                autoProgress = e.target.checked;
                if (autoProgress) {
                    showTooltip({clientX: e.target.offsetLeft, clientY: e.target.offsetTop}, '이제 각 단계가 자동으로 진행됩니다');
                    setTimeout(hideTooltip, 2000);
                }
            });
        });
        
        // 통합된 단계 진행 함수
        function proceedToStep(step) {
            moveToStep(step, true);
            
            if (!currentData) return;
            
            // 각 단계별 초기화 함수 실행
            console.log(`proceedToStep - 단계 ${step} 실행`);
            switch(step) {
                case 2: 
                    console.log('validateData() 호출 시작');
                    validateData(); 
                    break;
                case 3: testAssumptions(); break;
                case 4: recommendMethod(); break;
                case 5: runAnalysis(); break;
            }
        }
        
        // 기존 함수명 유지 (하위 호환성)
        function proceedToStep2() { proceedToStep(2); }
        function proceedToStep3() { proceedToStep(3); }
        function proceedToStep4() { proceedToStep(4); }
        function proceedToStep5() { proceedToStep(5); }
        
        // 데이터 검증
        async function validateData(force = false) {
            console.log('validateData 호출됨', { force, currentData: !!currentData, dataKeys: currentData ? Object.keys(currentData) : null, pyodide: !!pyodide });
            
            if (!currentData) {
                document.getElementById('dataValidation').innerHTML = 
                    '<div class="warning-box">데이터가 없습니다. 파일을 먼저 업로드해주세요.</div>';
                return;
            }
            
            // 이미 검증 결과가 있고 강제 재검증이 아니면 기존 결과 표시
            if (analysisResults.validation && !force) {
                displayValidationResults(analysisResults.validation);
                return;
            }
            
            // Pyodide 여부와 관계없이 JavaScript 상세 검증 수행
            console.log('JavaScript 상세 검증 수행');
            document.getElementById('dataValidation').innerHTML = 
                '<div class="info-box">검증 중입니다...</div>';
            
            // JavaScript로 상세 검증 수행
            setTimeout(() => performBasicValidation(), 100);
        }
        
        // 검증 결과 재표시
        function displayValidationResults(validation) {
            document.getElementById('rowCount').textContent = validation.rows;
            document.getElementById('colCount').textContent = validation.columns;
            
            if (validation.tableData) {
                document.getElementById('tableHeader').innerHTML = 
                    validation.tableData.headers.map(h => 
                        `<th class="px-4 py-2 text-left font-medium text-gray-700">${h}</th>`
                    ).join('');
                document.getElementById('tableBody').innerHTML = validation.tableData.body;
            }
            
            let validationHtml = '';
            if (validation.valid) {
                validationHtml = '<div class="success-box">✅ 데이터 검증 완료: 문제가 발견되지 않았습니다</div>';
            } else {
                validationHtml = '<div class="warning-box">⚠️ 데이터 문제 발견:<ul class="mt-2">';
                validation.issues.forEach(issue => {
                    validationHtml += `<li>• ${issue}</li>`;
                });
                validationHtml += '</ul></div>';
            }
            document.getElementById('dataValidation').innerHTML = validationHtml;
            
            // 설명 박스 표시
            document.getElementById('step2Explanation').classList.remove('hidden');
            
            // 자동 진행 (옵션이 켜져있는 경우)
            if (autoProgress) {
                setTimeout(() => proceedToStep3(), 2000);
            }
        }
        
        // JavaScript 기본 검증 함수
        function performBasicValidation() {
            console.log('performBasicValidation 시작됨');
            if (!currentData) {
                console.log('currentData가 없음');
                return;
            }
            
            const columns = Object.keys(currentData);
            const rows = currentData[columns[0]]?.length || 0;
            console.log('데이터 구조:', { rows, columns: columns.length });
            
            // 데이터 요약 정보 업데이트 (기본 데이터 정보)
            document.getElementById('rowCount').textContent = rows;
            document.getElementById('colCount').textContent = columns.length;
            
            // 테이블 표시 (데이터 미리보기)
            const headerHtml = columns.map(col => 
                `<th class="px-4 py-2 text-left font-medium text-gray-700">${col}</th>`
            ).join('');
            document.getElementById('tableHeader').innerHTML = headerHtml;
            
            let bodyHtml = '';
            for (let i = 0; i < Math.min(5, rows); i++) {
                bodyHtml += '<tr>';
                columns.forEach(col => {
                    bodyHtml += `<td class="px-4 py-2">${currentData[col][i] || ''}</td>`;
                });
                bodyHtml += '</tr>';
            }
            
            if (rows > 5) {
                bodyHtml += `<tr><td colspan="${columns.length}" class="px-4 py-2 text-center text-gray-500">... ${rows - 5}개 행 더 있음 ...</td></tr>`;
            }
            
            document.getElementById('tableBody').innerHTML = bodyHtml;
            
            // 통계 분석용 상세 검증 수행
            let issues = [];
            let validationDetails = [];
            let numericColumns = [];
            let textColumns = [];
            let groupColumns = [];
            let analysisRecommendations = [];
            
            for (let col of columns) {
                const values = currentData[col] || [];
                const validValues = values.filter(v => v != null && v !== '' && v !== undefined);
                
                // 결측치 확인
                const nullCount = values.length - validValues.length;
                if (nullCount > 0) {
                    if (nullCount / values.length > 0.2) {
                        issues.push(`${col}: 결측치가 20% 이상 (${nullCount}개)`);
                    } else {
                        validationDetails.push(`${col}: 결측치 ${nullCount}개 (${(nullCount/values.length*100).toFixed(1)}%)`);
                    }
                }
                
                // 데이터 타입 및 통계적 특성 분석
                const numericValues = validValues.filter(v => !isNaN(parseFloat(v)) && isFinite(v));
                const numericRatio = validValues.length > 0 ? (numericValues.length / validValues.length) : 0;
                
                if (numericRatio >= 0.8 && numericValues.length >= 3) {
                    numericColumns.push(col);
                    const nums = numericValues.map(v => parseFloat(v));
                    const min = Math.min(...nums);
                    const max = Math.max(...nums);
                    const mean = nums.reduce((a, b) => a + b, 0) / nums.length;
                    const variance = nums.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / (nums.length - 1);
                    const std = Math.sqrt(variance);
                    
                    // 분포 특성 확인
                    const range = max - min;
                    const cv = std / mean; // 변동계수
                    
                    validationDetails.push(`${col}: 연속형 변수 (N=${nums.length}, 평균=${mean.toFixed(2)}, 표준편차=${std.toFixed(2)}, 범위=${min.toFixed(2)}~${max.toFixed(2)})`);
                    
                    // 이상치 확인 (IQR 방법)
                    const sorted = nums.sort((a, b) => a - b);
                    const q1 = sorted[Math.floor(sorted.length * 0.25)];
                    const q3 = sorted[Math.floor(sorted.length * 0.75)];
                    const iqr = q3 - q1;
                    const outliers = nums.filter(v => v < q1 - 1.5 * iqr || v > q3 + 1.5 * iqr);
                    
                    if (outliers.length > 0) {
                        validationDetails.push(`  └ 잠재적 이상치 ${outliers.length}개 발견`);
                    }
                    
                } else {
                    const uniqueValues = [...new Set(validValues)];
                    const isGroupVariable = uniqueValues.length >= 2 && uniqueValues.length <= Math.max(10, values.length * 0.5);
                    
                    if (isGroupVariable) {
                        groupColumns.push(col);
                        validationDetails.push(`${col}: 그룹 변수 (${uniqueValues.length}개 그룹: ${uniqueValues.slice(0, 5).join(', ')}${uniqueValues.length > 5 ? '...' : ''})`);
                        
                        // 그룹별 개수 확인
                        const groupCounts = {};
                        validValues.forEach(v => groupCounts[v] = (groupCounts[v] || 0) + 1);
                        const minGroupSize = Math.min(...Object.values(groupCounts));
                        const maxGroupSize = Math.max(...Object.values(groupCounts));
                        
                        validationDetails.push(`  └ 그룹 크기: ${minGroupSize}~${maxGroupSize}개`);
                        
                        if (minGroupSize < 3) {
                            issues.push(`${col}: 일부 그룹의 크기가 너무 작음 (최소 ${minGroupSize}개)`);
                        }
                    } else {
                        textColumns.push(col);
                        validationDetails.push(`${col}: 텍스트/ID 변수 (${uniqueValues.length}개 고유값)`);
                    }
                }
            }
            
            // 데이터 특성 기반 통계 분석 추천
            let primaryRecommendation = "";
            
            // 1. 그룹 비교 분석 (가장 일반적)
            if (numericColumns.length >= 1 && groupColumns.length >= 1) {
                const dependentVar = numericColumns[0];
                
                // 여러 그룹 변수가 있는 경우 (이원/다원 분산분석)
                if (groupColumns.length >= 2) {
                    const factorInfo = groupColumns.map(col => {
                        const uniqueGroups = [...new Set(currentData[col])];
                        return `${col}(${uniqueGroups.length}수준)`;
                    });
                    
                    primaryRecommendation = `🎯 추천: "${dependentVar}"에 대한 ${factorInfo.join(' × ')} ${groupColumns.length}원분산분석`;
                    
                    if (groupColumns.length === 2) {
                        analysisRecommendations.push("이원분산분석(Two-way ANOVA) → 주효과 및 상호작용 효과 검정");
                        analysisRecommendations.push("사후분석 → 단순 주효과 분석 또는 다중비교");
                    } else {
                        analysisRecommendations.push(`다원분산분석(${groupColumns.length}-way ANOVA) → 주효과 및 상호작용 검정`);
                        analysisRecommendations.push("복잡한 상호작용 해석 필요");
                    }
                }
                // 단일 그룹 변수인 경우 (일원분산분석)
                else {
                    const groupCol = groupColumns[0];
                    const uniqueGroups = [...new Set(currentData[groupCol])];
                    
                    console.log('그룹 분석:', {
                        groupCol,
                        uniqueGroups,
                        groupCount: uniqueGroups.length,
                        dependentVar
                    });
                    
                    if (uniqueGroups.length === 2) {
                        primaryRecommendation = `🎯 추천: "${dependentVar}" 변수에 대한 "${groupCol}" 그룹(${uniqueGroups.join(', ')}) 간 차이 검정 (독립 t-검정)`;
                        analysisRecommendations.push("독립 t-검정 → 정규성 확인 후 t-test 또는 Mann-Whitney U 검정");
                    } else if (uniqueGroups.length >= 3) {
                        primaryRecommendation = `🎯 추천: "${dependentVar}" 변수에 대한 "${groupCol}" ${uniqueGroups.length}개 그룹 간 차이 분석 (일원분산분석)`;
                        analysisRecommendations.push("일원분산분석(ANOVA) → 정규성·등분산성 확인 후 ANOVA 또는 Kruskal-Wallis");
                    }
                }
                
                if (numericColumns.length >= 2) {
                    analysisRecommendations.push("추가 분석: 그룹별 상관분석 또는 다변량분석 가능");
                }
            }
            
            // 2. 상관/회귀 분석
            else if (numericColumns.length >= 2) {
                primaryRecommendation = `🎯 추천: "${numericColumns.slice(0,2).join('" 과 "')}" 간 관계 분석 (상관분석/회귀분석)`;
                analysisRecommendations.push("상관분석 → Pearson 또는 Spearman 상관계수");
                analysisRecommendations.push("회귀분석 → 단순/다중 선형회귀 또는 비선형회귀");
            }
            
            // 3. 기술통계만 가능
            else if (numericColumns.length >= 1) {
                primaryRecommendation = `📊 기본 분석: "${numericColumns[0]}" 변수의 기술통계 및 분포 분석`;
                analysisRecommendations.push("기술통계 → 평균, 표준편차, 분위수, 히스토그램");
                analysisRecommendations.push("정규성 검정 → Shapiro-Wilk 또는 Kolmogorov-Smirnov");
            }
            
            // 4. 범주형 데이터 분석
            else if (groupColumns.length >= 2) {
                primaryRecommendation = `📋 범주형 분석: "${groupColumns.slice(0,2).join('" 과 "')}" 간 연관성 분석`;
                analysisRecommendations.push("카이제곱 검정 → 범주형 변수 간 독립성 검정");
            }
            
            // 5. 분석 불가
            else {
                primaryRecommendation = "⚠️ 현재 데이터로는 통계적 추론이 제한적입니다";
                analysisRecommendations.push("데이터 전처리 또는 추가 데이터 수집을 권장합니다");
            }
            
            // 추가 일반적 분석
            if (numericColumns.length >= 1) {
                analysisRecommendations.push("탐색적 데이터 분석(EDA) → 분포, 이상치, 패턴 확인");
            }
            
            let validationHtml = '';
            if (issues.length === 0) {
                validationHtml = `
                    <div class="success-box">
                        <h4 class="font-semibold mb-2">✅ 데이터 검증 완료</h4>
                        <div class="text-sm space-y-2">
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <p><strong>📊 데이터 구조:</strong></p>
                                    <ul class="ml-4 text-xs space-y-1">
                                        <li>• 전체: ${rows}개 행, ${columns.length}개 열</li>
                                        <li>• 연속형 변수: ${numericColumns.length}개${numericColumns.length > 0 ? ' (' + numericColumns.join(', ') + ')' : ''}</li>
                                        <li>• 그룹 변수: ${groupColumns.length}개${groupColumns.length > 0 ? ' (' + groupColumns.join(', ') + ')' : ''}</li>
                                        <li>• 기타 변수: ${textColumns.length}개${textColumns.length > 0 ? ' (' + textColumns.join(', ') + ')' : ''}</li>
                                    </ul>
                                </div>
                                <div>
                                    <p><strong>🔍 분석 추천:</strong></p>
                                    ${primaryRecommendation ? `<div class="bg-blue-100 p-2 rounded mb-2 text-xs"><strong>${primaryRecommendation}</strong></div>` : ''}
                                    <ul class="ml-4 text-xs space-y-1">
                                        ${analysisRecommendations.map(rec => `<li>• ${rec}</li>`).join('')}
                                    </ul>
                                </div>
                            </div>
                        </div>
                        <details class="mt-3">
                            <summary class="cursor-pointer text-sm font-medium">📋 상세 변수 정보 보기</summary>
                            <ul class="mt-2 text-xs space-y-1 ml-4">
                                ${validationDetails.map(detail => `<li>${detail}</li>`).join('')}
                            </ul>
                        </details>
                    </div>
                `;
            } else {
                validationHtml = `
                    <div class="warning-box">
                        <h4 class="font-semibold mb-2">⚠️ 데이터 품질 문제 발견</h4>
                        <div class="bg-red-50 p-3 rounded mb-3">
                            <p class="text-sm font-medium mb-2">해결 필요한 문제:</p>
                            <ul class="text-sm space-y-1">
                                ${issues.map(issue => `<li>• ${issue}</li>`).join('')}
                            </ul>
                        </div>
                        <div class="text-sm space-y-2">
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <p><strong>📊 현재 데이터 구조:</strong></p>
                                    <ul class="ml-4 text-xs space-y-1">
                                        <li>• 전체: ${rows}개 행, ${columns.length}개 열</li>
                                        <li>• 연속형 변수: ${numericColumns.length}개</li>
                                        <li>• 그룹 변수: ${groupColumns.length}개</li>
                                    </ul>
                                </div>
                                <div>
                                    <p><strong>🔍 분석 추천:</strong></p>
                                    ${primaryRecommendation ? `<div class="bg-yellow-100 p-2 rounded mb-2 text-xs"><strong>${primaryRecommendation}</strong></div>` : ''}
                                    <ul class="ml-4 text-xs space-y-1">
                                        ${analysisRecommendations.map(rec => `<li>• ${rec}</li>`).join('')}
                                    </ul>
                                </div>
                            </div>
                        </div>
                        <details class="mt-3">
                            <summary class="cursor-pointer text-sm font-medium">📋 상세 변수 정보 보기</summary>
                            <ul class="mt-2 text-xs space-y-1 ml-4">
                                ${validationDetails.map(detail => `<li>${detail}</li>`).join('')}
                            </ul>
                        </details>
                    </div>
                `;
            }
            
            // 검증 상태 박스에 더 상세한 정보 표시
            let simpleValidationHtml = '';
            
            // 이상치와 결측치 요약
            let outlierInfo = '';
            let missingInfo = '';
            
            for (const col of columns) {
                const values = currentData[col];
                const missingCount = values.filter(v => v === null || v === '' || v === undefined).length;
                if (missingCount > 0) {
                    if (!missingInfo) missingInfo = '결측치: ';
                    missingInfo += `${col}(${missingCount}개) `;
                }
            }
            
            // 이상치 정보는 validationDetails에서 추출
            const outlierLines = validationDetails.filter(d => d.includes('이상치'));
            if (outlierLines.length > 0) {
                outlierInfo = outlierLines.join(', ');
            }
            
            if (issues.length === 0) {
                simpleValidationHtml = `
                    <div class="text-green-600 text-sm">
                        <div class="font-medium">✅ 품질 검사 통과</div>
                        <div class="text-xs mt-1 space-y-1">
                            <div>• 데이터: ${rows}개 행, ${columns.length}개 열</div>
                            <div>• 변수: ${numericColumns.length}개 연속형, ${groupColumns.length}개 그룹형</div>
                            ${missingInfo ? `<div class="text-yellow-600">• ${missingInfo}</div>` : '<div>• 결측치 없음</div>'}
                            ${outlierInfo ? `<div class="text-orange-600">• ${outlierInfo}</div>` : '<div>• 이상치 없음</div>'}
                        </div>
                    </div>
                `;
            } else {
                simpleValidationHtml = `
                    <div class="text-orange-600 text-sm">
                        <div class="font-medium">⚠️ ${issues.length}개 문제 발견</div>
                        <div class="text-xs mt-1 space-y-1">
                            ${issues.slice(0, 3).map(issue => `<div>• ${issue}</div>`).join('')}
                            ${issues.length > 3 ? '<div>• ...</div>' : ''}
                            ${missingInfo ? `<div>• ${missingInfo}</div>` : ''}
                            ${outlierInfo ? `<div>• ${outlierInfo}</div>` : ''}
                        </div>
                    </div>
                `;
            }
            
            console.log('dataValidation 업데이트:', simpleValidationHtml);
            const validationElement = document.getElementById('dataValidation');
            if (validationElement) {
                validationElement.innerHTML = simpleValidationHtml;
                console.log('dataValidation 업데이트 성공');
            } else {
                console.error('dataValidation 요소를 찾을 수 없음');
            }
            
            // 상세 결과를 별도 영역에 표시
            const detailedResults = document.getElementById('step2DetailedResults');
            const detailedContent = document.getElementById('detailedValidationContent');
            
            if (detailedResults) {
                detailedResults.classList.remove('hidden');
                console.log('step2DetailedResults 표시됨');
            } else {
                console.error('step2DetailedResults 요소를 찾을 수 없음');
            }
            
            if (detailedContent) {
                detailedContent.innerHTML = validationHtml;
                console.log('detailedValidationContent 업데이트됨');
            } else {
                console.error('detailedValidationContent 요소를 찾을 수 없음');
            }
            
            // 결과 저장
            analysisResults.validation = {
                rows: rows,
                columns: columns.length,
                valid: issues.length === 0,
                issues: issues,
                numericColumns: numericColumns,
                groupColumns: groupColumns,  // 그룹 변수 추가
                textColumns: textColumns,
                details: validationDetails,
                primaryRecommendation: primaryRecommendation,
                analysisRecommendations: analysisRecommendations
            };
            
            // UI 요소들 표시 및 활성화 (유틸리티 함수 사용)
            console.log('UI 요소 표시 시작');
            showElement('step2Explanation');
            showElement('step2NextButton');
            console.log('step2NextButton 표시 완료');
            enableButton('#step2NextButton button');
            enableButton('#step2Explanation button[onclick="proceedToStep3()"]');
            console.log('버튼 활성화 완료');
            
            // 자동 진행 (검증 성공 시)
            console.log('자동 진행 체크:', { autoProgress, issues: issues.length });
            if (autoProgress && issues.length === 0) {
                console.log('자동 진행 시작 - 3초 후 다음 단계로');
                // 성공 메시지와 함께 자동 진행 예고
                const countdownEl = document.createElement('div');
                countdownEl.className = 'mt-2 text-center text-sm text-blue-600';
                countdownEl.innerHTML = '⏱️ 3초 후 자동으로 다음 단계로 진행됩니다...';
                
                const validationElement = document.getElementById('dataValidation');
                if (validationElement) {
                    validationElement.appendChild(countdownEl);
                } else {
                    console.error('dataValidation 요소를 찾을 수 없어 자동 진행 메시지 추가 실패');
                }
                
                setTimeout(() => {
                    console.log('자동 진행 실행 - proceedToStep3() 호출');
                    if (countdownEl.parentNode) countdownEl.remove();
                    proceedToStep3();
                }, 3000);
            }
        }

        // 재검증 함수
        function revalidateData() {
            analysisResults.validation = null;
            validateData(true);
        }
        
        // 디버그: 검증 상태 강제 표시 함수
        function testValidationDisplay() {
            console.log('testValidationDisplay 호출됨');
            const validationElement = document.getElementById('dataValidation');
            if (validationElement) {
                validationElement.innerHTML = '<div class="text-green-600 text-sm"><div class="font-medium">✅ 테스트 검증 표시</div></div>';
                console.log('검증 상태 강제 표시 성공');
            } else {
                console.error('dataValidation 요소를 찾을 수 없음');
            }
        }
        
        // 디버그: 강제 검증 실행
        function forceValidation() {
            console.log('=== 강제 검증 시작 ===');
            // 테스트 데이터 설정
            currentData = {
                '그룹': ['A', 'A', 'A', 'B', 'B', 'B'],
                '값': [10, 12, 14, 15, 17, 19]
            };
            console.log('테스트 데이터 설정 완료');
            
            // 2단계로 이동
            moveToStep(2);
            console.log('2단계로 이동 완료');
            
            // 검증 실행
            validateData(true);
            console.log('validateData 호출 완료');
        }
        
        // 가정 검정 (실제 SciPy 사용)
        async function testAssumptions() {
            // 이미 결과가 있으면 표시만
            if (analysisResults.assumptions) {
                displayAssumptionResults(analysisResults.assumptions);
                return;
            }
            
            if (!currentData || !analysisResults.validation) {
                alert('먼저 데이터를 검증해주세요.');
                return;
            }
            
            // 새로 분석
            document.getElementById('normalityResults').innerHTML = '<p class="text-gray-600">정규성 검정 중...</p>';
            document.getElementById('homogeneityResults').innerHTML = '<p class="text-gray-600">등분산성 검정 중...</p>';
            
            // 검정할 변수들 찾기 (validation에서 저장된 변수 사용)
            const numericColumns = analysisResults.validation.numericColumns || [];
            let groupColumns = analysisResults.validation.groupColumns || [];
            
            // groupColumns가 정의되지 않은 경우 다시 찾기
            if (!groupColumns || groupColumns.length === 0) {
                groupColumns = [];
                const columns = Object.keys(currentData);
                for (const col of columns) {
                    const values = currentData[col];
                    const validValues = values.filter(v => v !== null && v !== '' && v !== undefined);
                    const numericValues = validValues.filter(v => !isNaN(Number(v)));
                    
                    // 숫자가 아닌 값이 많고, 고유값이 적당한 경우 그룹 변수로 판단
                    if (numericValues.length < validValues.length * 0.8) {
                        const uniqueValues = [...new Set(validValues)];
                        if (uniqueValues.length >= 2 && uniqueValues.length <= Math.max(10, values.length * 0.5)) {
                            groupColumns.push(col);
                        }
                    }
                }
            }
            
            // Pyodide 체크
            if (!window.pyodide) {
                alert('통계 엔진이 로드되지 않았습니다. 잠시 후 다시 시도해주세요.');
                return;
            }
            
            // 정규성 검정 수행 (실제 SciPy 사용)
            const normalityResults = [];
            const homogeneityResults = [];
            
            try {
                // 1. 정규성 검정 - 각 수치형 변수에 대해
                for (const col of numericColumns) {
                    const values = currentData[col].filter(v => !isNaN(Number(v)) && v !== '');
                    const nums = values.map(v => parseFloat(v));
                    
                    if (nums.length < 3) {
                        normalityResults.push({
                            variable: col,
                            test: 'N/A',
                            statistic: null,
                            pValue: null,
                            isNormal: false,
                            interpretation: '표본 수 부족 (n < 3)',
                            sampleSize: nums.length
                        });
                        continue;
                    }
                    
                    // Python으로 정규성 검정 실행
                    pyodide.globals.set('test_values', nums);
                    const result = await pyodide.runPythonAsync(`
                        result = test_normality(test_values)
                        result
                    `);
                    
                    const normResult = result.toJs();
                    
                    normalityResults.push({
                        variable: col,
                        test: normResult.get('test'),
                        statistic: normResult.get('statistic'),
                        pValue: normResult.get('pValue'),
                        isNormal: normResult.get('isNormal'),
                        skewness: normResult.get('skewness'),
                        kurtosis: normResult.get('kurtosis'),
                        sampleSize: normResult.get('n'),
                        interpretation: normResult.get('isNormal') ? 
                            `정규분포를 따름 (${normResult.get('test')}, p = ${normResult.get('pValue')?.toFixed(3)} > 0.05)` : 
                            `정규분포를 따르지 않음 (${normResult.get('test')}, p = ${normResult.get('pValue')?.toFixed(3)} < 0.05)`,
                        recommendation: !normResult.get('isNormal') ? 
                            '비모수 검정 또는 데이터 변환을 고려하세요' : 
                            '모수 검정 사용 가능'
                    });
                }
                
                // 2. 등분산성 검정 - 그룹이 있는 경우
                if (groupColumns.length > 0) {
                    for (const numCol of numericColumns) {
                        for (const groupCol of groupColumns) {
                            // 그룹별 데이터 준비
                            const groupsData = {};
                            for (let i = 0; i < currentData[groupCol].length; i++) {
                                const group = currentData[groupCol][i];
                                const value = currentData[numCol][i];
                                
                                if (group && !isNaN(parseFloat(value))) {
                                    if (!groupsData[group]) groupsData[group] = [];
                                    groupsData[group].push(parseFloat(value));
                                }
                            }
                            
                            // 그룹이 2개 이상인 경우만 검정
                            const validGroups = Object.entries(groupsData)
                                .filter(([_, vals]) => vals.length >= 2);
                            
                            if (validGroups.length < 2) {
                                continue;
                            }
                            
                            // Python으로 등분산성 검정 실행
                            const groupsDict = Object.fromEntries(validGroups);
                            pyodide.globals.set('test_groups', groupsDict);
                            const homResult = await pyodide.runPythonAsync(`
                                result = test_homogeneity(test_groups)
                                result
                            `);
                            
                            const homData = homResult.toJs();
                            
                            // 정규성 결과 확인하여 적절한 검정 해석
                            const normalityResult = normalityResults.find(r => r.variable === numCol);
                            const useTest = normalityResult && normalityResult.isNormal && 
                                          homData.get('bartlett')?.pValue ? 
                                          'Bartlett' : homData.get('test');
                            
                            homogeneityResults.push({
                                variable: numCol,
                                groupVariable: groupCol,
                                test: useTest,
                                statistic: homData.get('statistic'),
                                pValue: homData.get('pValue'),
                                isHomogeneous: homData.get('isHomogeneous'),
                                variances: homData.get('variances'),
                                varianceRatio: homData.get('variance_ratio'),
                                groupCount: homData.get('groups'),
                                interpretation: homData.get('isHomogeneous') ?
                                    `등분산성 만족 (${useTest}: p = ${homData.get('pValue')?.toFixed(3)} > 0.05)` :
                                    `등분산성 위배 (${useTest}: p = ${homData.get('pValue')?.toFixed(3)} < 0.05)`,
                                recommendation: !homData.get('isHomogeneous') ?
                                    '등분산 가정이 위배되어 Welch 검정 권장' :
                                    '등분산 가정 충족, 일반 검정 사용 가능'
                            });
                        }
                    }
                }
            } catch (error) {
                console.error('가정 검정 오류:', error);
                document.getElementById('normalityResults').innerHTML = `
                    <div class="error-box">
                        <p class="font-semibold">오류 발생</p>
                        <p class="text-sm">${error.message}</p>
                    </div>
                `;
                return;
            }
            
            // 결과 저장
            analysisResults.assumptions = {
                normality: normalityResults,
                homogeneity: homogeneityResults,
                recommendation: generateAssumptionRecommendation(normalityResults, homogeneityResults)
            };
            
            displayAssumptionResults(analysisResults.assumptions);
            
            // 설명 박스와 버튼 표시
            document.getElementById('step3Explanation').classList.remove('hidden');
            document.getElementById('step3NextButton').classList.remove('hidden');
            document.getElementById('step3NextButton').querySelector('button').disabled = false;
            
            if (autoProgress) {
                setTimeout(() => proceedToStep4(), 3000);
            }
        }
        
        function generateAssumptionRecommendation(normalityResults, homogeneityResults) {
            const allNormal = normalityResults.every(r => r.isNormal);
            const allHomogeneous = homogeneityResults.length === 0 || homogeneityResults.every(r => r.isHomogeneous);
            
            let recommendation = '';
            if (allNormal && allHomogeneous) {
                recommendation = '✅ 모든 가정이 충족됨 → 모수적 검정(t-test, ANOVA) 사용 가능';
            } else if (!allNormal && allHomogeneous) {
                recommendation = '⚠️ 정규성 가정 위배 → 비모수 검정(Mann-Whitney, Kruskal-Wallis) 권장';
            } else if (allNormal && !allHomogeneous) {
                recommendation = '⚠️ 등분산성 가정 위배 → Welch 검정 또는 비모수 검정 권장';
            } else {
                recommendation = '⚠️ 정규성과 등분산성 모두 위배 → 비모수 검정 강력 권장';
            }
            return recommendation;
        }
        
        function displayAssumptionResults(results) {
            // 정규성 검정 결과
            let normalityHtml = '<div class="space-y-2">';
            if (results.normality && results.normality.length > 0) {
                normalityHtml += '<h4 class="font-semibold">📊 정규성 검정 결과</h4>';
                for (const result of results.normality) {
                    const statusIcon = result.isNormal ? '✅' : '⚠️';
                    const statusColor = result.isNormal ? 'green' : 'orange';
                    normalityHtml += `
                        <div class="bg-${statusColor}-50 p-3 rounded">
                            <div class="flex justify-between items-start">
                                <div>
                                    <div class="font-medium">${statusIcon} ${result.variable}</div>
                                    <div class="text-sm text-gray-600 mt-1">
                                        • 검정방법: ${result.test}<br>
                                        • 통계량: ${result.statistic.toFixed(3)}<br>
                                        • p-값: ${result.pValue.toFixed(3)}<br>
                                        • 왜도: ${result.skewness.toFixed(2)}, 첨도: ${result.kurtosis.toFixed(2)}
                                    </div>
                                </div>
                                <div class="text-sm font-medium text-${statusColor}-700">
                                    ${result.interpretation}
                                </div>
                            </div>
                            <div class="text-xs text-gray-500 mt-2">
                                💡 설명: ${result.isNormal ? 
                                    'p값이 0.05보다 커서 정규분포 가정을 기각할 수 없음. 데이터가 종 모양의 대칭적 분포를 보임.' :
                                    'p값이 0.05보다 작아 정규분포 가정을 기각. 데이터가 치우쳐 있거나 이상치가 있을 가능성.'}
                            </div>
                        </div>
                    `;
                }
            } else {
                normalityHtml += '<p class="text-gray-500">정규성 검정할 연속형 변수가 없습니다.</p>';
            }
            normalityHtml += '</div>';
            document.getElementById('normalityResults').innerHTML = normalityHtml;
            
            // 등분산성 검정 결과
            let homogeneityHtml = '<div class="space-y-2">';
            if (results.homogeneity && results.homogeneity.length > 0) {
                homogeneityHtml += '<h4 class="font-semibold">📊 등분산성 검정 결과</h4>';
                for (const result of results.homogeneity) {
                    const statusIcon = result.isHomogeneous ? '✅' : '⚠️';
                    const statusColor = result.isHomogeneous ? 'green' : 'orange';
                    homogeneityHtml += `
                        <div class="bg-${statusColor}-50 p-3 rounded">
                            <div class="flex justify-between items-start">
                                <div>
                                    <div class="font-medium">${statusIcon} ${result.variable} by ${result.groupVariable}</div>
                                    <div class="text-sm text-gray-600 mt-1">
                                        • 검정방법: ${result.test} 검정<br>
                                        • F-통계량: ${result.statistic.toFixed(3)}<br>
                                        • p-값: ${result.pValue.toFixed(3)}
                                    </div>
                                </div>
                                <div class="text-sm font-medium text-${statusColor}-700">
                                    ${result.interpretation}
                                </div>
                            </div>
                            <div class="text-xs text-gray-500 mt-2">
                                💡 설명: ${result.isHomogeneous ?
                                    '그룹 간 분산이 유사하여 등분산성 가정 충족. 표준 ANOVA 사용 가능.' :
                                    '그룹 간 분산 차이가 커서 등분산성 가정 위배. Welch ANOVA 또는 비모수 검정 고려.'}
                            </div>
                        </div>
                    `;
                }
            } else {
                homogeneityHtml += '<p class="text-gray-500">등분산성 검정할 그룹 변수가 없습니다.</p>';
            }
            homogeneityHtml += '</div>';
            document.getElementById('homogeneityResults').innerHTML = homogeneityHtml;
            
            // 종합 추천
            if (results.recommendation) {
                const recommendHtml = `
                    <div class="mt-4 p-4 bg-blue-50 rounded-lg border border-blue-200">
                        <h4 class="font-semibold text-blue-800 mb-2">🎯 종합 분석 및 권장사항</h4>
                        <p class="text-sm text-blue-700">${results.recommendation}</p>
                    </div>
                `;
                document.getElementById('homogeneityResults').innerHTML += recommendHtml;
            }
        }
        
        // 가정 재검정
        function retestAssumptions() {
            analysisResults.assumptions = null; // 기존 결과 삭제
            testAssumptions(); // 재검정 실행
        }
        
        // 방법 추천
        function recommendMethod() {
            // 이미 결과가 있으면 표시만
            if (analysisResults.method) {
                displayMethodRecommendation(analysisResults.method);
                return;
            }
            
            // 가정 검정 결과가 없으면 경고
            if (!analysisResults.assumptions) {
                alert('먼저 통계적 가정 검정을 완료해주세요.');
                return;
            }
            
            // 데이터와 가정 검정 결과를 바탕으로 최적 방법 추천
            const method = analyzeDataForMethod();
            
            analysisResults.method = method;
            displayMethodRecommendation(method);
            
            // 설명 박스와 버튼 표시
            document.getElementById('step4Explanation').classList.remove('hidden');
            document.getElementById('step4NextButton').classList.remove('hidden');
            document.getElementById('step4NextButton').querySelector('button').disabled = false;
            
            if (autoProgress) {
                setTimeout(() => proceedToStep5(), 3000);
            }
        }
        
        function analyzeDataForMethod() {
            // 가정 검정 결과와 데이터 특성 확인
            const validation = analysisResults.validation || {};
            const assumptions = analysisResults.assumptions || {};
            const numericColumns = validation.numericColumns || [];
            const groupColumns = validation.groupColumns || [];
            
            // 가정 충족 여부 확인
            const allNormal = assumptions.normality && assumptions.normality.every(r => r.isNormal);
            const allHomogeneous = !assumptions.homogeneity || assumptions.homogeneity.length === 0 || 
                                  assumptions.homogeneity.every(r => r.isHomogeneous);
            
            if (!currentData) {
                return {
                    name: 'One-way ANOVA',
                    description: '기본 그룹 비교 분석',
                    reason: '데이터를 확인할 수 없습니다.',
                    primary: { name: 'One-way ANOVA', type: 'parametric' },
                    alternatives: [],
                    reasoning: ['데이터를 확인할 수 없습니다']
                };
            }
            
            const columns = Object.keys(currentData);
            const numericCols = [];
            const categoricalCols = [];
            
            // 컬럼 유형 분석
            for (const col of columns) {
                const values = currentData[col];
                const numericCount = values.filter(v => !isNaN(v) && v !== null && v !== '').length;
                const totalCount = values.filter(v => v !== null && v !== '').length;
                
                if (numericCount / totalCount > 0.8) {
                    numericCols.push(col);
                } else {
                    categoricalCols.push(col);
                }
            }
            
            // 방법 결정 로직
            
            // 1. 대응 표본 또는 반복측정 감지
            const hasPairedKeywords = columns.some(col => {
                const lowerCol = col.toLowerCase();
                return lowerCol.includes('before') || lowerCol.includes('after') ||
                       lowerCol.includes('pre') || lowerCol.includes('post') ||
                       lowerCol.includes('time') || lowerCol.includes('전') || 
                       lowerCol.includes('후') || lowerCol.includes('시간') ||
                       lowerCol.includes('paired') || lowerCol.includes('대응');
            });
            
            const hasSubjectId = columns.some(col => {
                const lowerCol = col.toLowerCase();
                return lowerCol.includes('subject') || lowerCol.includes('id') ||
                       lowerCol.includes('patient') || lowerCol.includes('환자') ||
                       lowerCol.includes('개체');
            });
            
            // 대응 표본 t검정 감지
            if (hasPairedKeywords && numericCols.length >= 2) {
                const isNormal = assumptions.normality && 
                                assumptions.normality.every(r => r.isNormal);
                return {
                    name: isNormal ? 'Paired t-test' : 'Wilcoxon Signed-Rank Test',
                    type: 'paired_test',
                    description: isNormal ? 
                        '대응 표본의 평균 차이를 검정합니다.' :
                        '대응 표본의 중앙값 차이를 검정합니다 (비모수).',
                    reason: `대응 표본 데이터가 감지되었고, 정규성: ${isNormal ? '충족' : '미충족'}`,
                    variables: numericCols.slice(0, 2),
                    isPaired: true
                };
            }
            
            // 반복측정 ANOVA 감지
            if (hasSubjectId && categoricalCols.length >= 1 && numericCols.length >= 1) {
                const groups = [...new Set(currentData[categoricalCols[0]])];
                if (groups.length >= 3) {
                    const isNormal = assumptions.normality && 
                                    assumptions.normality.every(r => r.isNormal);
                    return {
                        name: isNormal ? 'Repeated Measures ANOVA' : 'Friedman Test',
                        type: 'repeated_measures',
                        description: isNormal ?
                            '반복측정된 데이터의 그룹 간 차이를 분석합니다.' :
                            '반복측정된 데이터의 그룹 간 차이를 비모수적으로 분석합니다.',
                        reason: `반복측정 디자인이 감지되었고 ${groups.length}개 시점`,
                        factor: categoricalCols[0],
                        dependent: numericCols[0],
                        subjectId: columns.find(col => 
                            col.toLowerCase().includes('subject') || 
                            col.toLowerCase().includes('id')
                        )
                    };
                }
            }
            
            // 2. 범주형 데이터 분석 감지
            const allCategorical = columns.every(col => {
                const values = currentData[col];
                const numericCount = values.filter(v => !isNaN(v) && v !== null && v !== '').length;
                return numericCount / values.length < 0.2; // 80% 이상이 비숫자
            });
            
            if (allCategorical && columns.length >= 2) {
                return {
                    name: 'Chi-square Test',
                    type: 'chi_square',
                    description: '범주형 변수 간의 독립성을 검정합니다.',
                    reason: '모든 변수가 범주형으로 감지되어 카이제곱 검정이 적합합니다.',
                    variables: columns,
                    alternatives: [
                        "Fisher's Exact Test (표본 크기가 작을 때)",
                        "Cramer's V (효과 크기 측정)"
                    ]
                };
            }
            
            // Two-way ANOVA 감지 (2개 범주형 + 1개 수치형)
            if (categoricalCols.length >= 2 && numericCols.length >= 1) {
                return {
                    name: 'Two-way ANOVA',
                    type: 'two_way_anova',
                    description: '두 독립변수의 주효과와 상호작용 효과를 분석합니다.',
                    reason: `범주형 변수 ${categoricalCols.length}개와 종속변수 ${numericCols.length}개가 감지되어 이원분산분석이 적합합니다.`,
                    factors: categoricalCols.slice(0, 2),
                    dependent: numericCols[0]
                };
            }
            
            // 회귀분석 감지 (2개 이상 수치형)
            if (numericCols.length >= 2) {
                return {
                    name: numericCols.length === 2 ? 'Simple Linear Regression' : 'Multiple Regression',
                    type: 'regression',
                    description: numericCols.length === 2 ? 
                        '두 연속변수 간의 선형 관계를 분석합니다.' :
                        '여러 독립변수가 종속변수에 미치는 영향을 분석합니다.',
                    reason: `연속형 변수 ${numericCols.length}개가 감지되어 회귀분석이 적합합니다.`,
                    predictors: numericCols.slice(0, -1),
                    dependent: numericCols[numericCols.length - 1]
                };
            }
            
            // One-way ANOVA 감지 (1개 범주형 + 1개 수치형)
            if (categoricalCols.length >= 1 && numericCols.length >= 1) {
                const groups = [...new Set(currentData[categoricalCols[0]])];
                if (groups.length >= 3) {
                    return {
                        name: 'One-way ANOVA',
                        type: 'one_way_anova',
                        description: '3개 이상 그룹의 평균을 비교합니다.',
                        reason: `${groups.length}개 그룹이 감지되어 일원분산분석이 적합합니다.`,
                        factor: categoricalCols[0],
                        dependent: numericCols[0]
                    };
                } else if (groups.length === 2) {
                    return {
                        name: 'Independent t-test',
                        type: 'ttest',
                        description: '두 독립 그룹의 평균을 비교합니다.',
                        reason: '2개 그룹이 감지되어 독립표본 t검정이 적합합니다.',
                        factor: categoricalCols[0],
                        dependent: numericCols[0]
                    };
                }
            }
            
            // CPUE 분석 감지
            const cpueKeywords = ['catch', 'effort', 'cpue', '어획량', '어획노력'];
            const hasCPUE = columns.some(col => 
                cpueKeywords.some(keyword => col.toLowerCase().includes(keyword))
            );
            
            if (hasCPUE) {
                return {
                    name: 'CPUE Analysis',
                    type: 'cpue',
                    description: '어획노력당 어획량 분석으로 자원의 상대적 풍도를 평가합니다.',
                    reason: 'CPUE 관련 데이터가 감지되었습니다.',
                    special: 'fisheries'
                };
            }
            
            // 성장분석 감지
            const growthKeywords = ['length', 'weight', 'age', '전장', '체중', '연령'];
            const hasGrowth = columns.some(col => 
                growthKeywords.some(keyword => col.toLowerCase().includes(keyword))
            );
            
            if (hasGrowth) {
                return {
                    name: 'Growth Analysis',
                    type: 'growth',
                    description: '어류의 성장 패턴을 분석합니다.',
                    reason: '성장 관련 데이터가 감지되었습니다.',
                    special: 'fisheries'
                };
            }
            
            // 기본값
            return {
                name: 'Descriptive Statistics',
                type: 'descriptive',
                description: '기술통계로 데이터의 기본 특성을 파악합니다.',
                reason: '데이터 구조 분석 결과 기술통계 분석이 적합합니다.'
            };
        }
        
        function displayMethodRecommendation(method) {
            // 이전 버전과의 호환성 체크
            if (!method.primary) {
                // 구식 형식을 새 형식으로 변환
                method = {
                    primary: { name: method.name, description: method.description, type: method.type },
                    reasoning: [method.reason],
                    alternatives: []
                };
            }
            
            let html = `
                <div class="space-y-4">
                    <!-- 주요 추천 방법 -->
                    <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
                        <h4 class="font-semibold text-blue-800 mb-2">🎯 추천 분석 방법</h4>
                        <div class="text-lg font-medium text-blue-900">${method.primary.name}</div>
                        <div class="text-sm text-blue-700 mt-1">${method.primary.description || ''}</div>
                        <div class="mt-2 text-xs">
                            <span class="inline-block px-2 py-1 bg-white rounded">
                                ${method.primary.type === 'parametric' ? '📊 모수적 검정' : 
                                  method.primary.type === 'non-parametric' || method.primary.type === 'non_parametric' ? '📈 비모수 검정' : 
                                  method.primary.type === 'two_way_anova' || method.primary.type === 'one_way_anova' ? '📊 분산분석' :
                                  method.primary.type === 'regression' ? '📉 회귀분석' :
                                  method.primary.type === 'ttest' ? '📊 t-검정' :
                                  '📋 기술통계'}
                            </span>
                            ${method.primary.requirements ? `<div class="mt-1">${method.primary.requirements}</div>` : ''}
                            ${method.primary.postHoc ? `<div class="mt-1">📌 사후검정: ${method.primary.postHoc}</div>` : ''}
                        </div>
                    </div>
                    
                    <!-- 추천 이유 -->
                    ${method.reasoning && method.reasoning.length > 0 ? `
                    <div class="bg-gray-50 p-4 rounded-lg">
                        <h5 class="font-semibold mb-2">💡 선택 이유</h5>
                        <ul class="text-sm space-y-1">
                            ${method.reasoning.map(r => `<li>• ${r}</li>`).join('')}
                        </ul>
                    </div>
                    ` : ''}
                    
                    <!-- 대안 방법 -->
                    ${method.alternatives && method.alternatives.length > 0 ? `
                    <div class="bg-yellow-50 p-4 rounded-lg">
                        <h5 class="font-semibold mb-2">🔄 대체 가능한 방법</h5>
                        <ul class="text-sm space-y-2">
                            ${method.alternatives.map(alt => `
                                <li>
                                    <span class="font-medium">• ${alt.name}</span>
                                    <span class="text-xs text-gray-600 ml-2">(${alt.reason || ''})</span>
                                </li>
                            `).join('')}
                        </ul>
                    </div>
                    ` : ''}
                </div>
            `;
            
            document.getElementById('methodRecommendation').innerHTML = html;
        }
        
        // 분석 실행
        async function runAnalysis() {
            // 이미 결과가 있으면 바로 6단계로
            if (analysisResults.final) {
                moveToStep(6, true);
                displayResults();
                return;
            }
            
            // 필수 사전 단계 확인
            if (!analysisResults.method) {
                alert('먼저 분석 방법을 선택해주세요.');
                return;
            }
            
            // 분석 진행 상태 표시
            document.getElementById('analysisProgress').innerHTML = `
                <div class="text-center py-4">
                    <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
                    <p class="mt-2 text-gray-600">통계 분석을 수행하고 있습니다...</p>
                </div>
            `;
            
            // 실제 분석 수행 (Pyodide 사용)
            setTimeout(async () => {
                const startTime = Date.now();
                const result = await performStatisticalAnalysis();
                analysisResults.final = result;
                
                const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
                
                // 진행 상태 업데이트
                document.getElementById('analysisProgress').innerHTML = `
                    <div class="success-box">
                        <p class="font-semibold">✅ 분석 완료</p>
                        <p class="text-sm mt-1">총 소요시간: ${elapsed}초</p>
                    </div>
                `;
                
                // 6단계로 이동
                setTimeout(() => {
                    moveToStep(6, true);
                    displayResults();
                    
                    // 설명 박스 표시
                    document.getElementById('step5Explanation').classList.remove('hidden');
                }, 1000);
            }, 2000);
        }
        
        async function performStatisticalAnalysis() {
            // Pyodide가 준비되었는지 확인
            if (!window.pyodide || !pyodideReady) {
                console.warn('Pyodide not ready, using fallback calculations');
                return performStatisticalAnalysisFallback();
            }
            
            // 선택된 방법에 따라 다른 분석 수행
            const method = analysisResults.method.primary || analysisResults.method;
            const validation = analysisResults.validation;
            const numericColumns = validation.numericColumns || [];
            const groupColumns = validation.groupColumns || [];
            
            let result = {
                method: method.name,
                timestamp: new Date().toISOString(),
                data: {},
                statistics: {},
                interpretation: '',
                postHoc: null
            };
            
            try {
                // 분석 타입별 처리
                if (method.type === 'ttest' || method.name.includes('t-test')) {
                    // t-검정 (Pyodide 사용)
                    const dependentVar = numericColumns[0];
                    const groupVar = groupColumns[0];
                    const groups = [...new Set(currentData[groupVar])];
                    
                    // 그룹별 데이터 분리
                    const group1Data = [];
                    const group2Data = [];
                    for (let i = 0; i < currentData[groupVar].length; i++) {
                        const value = parseFloat(currentData[dependentVar][i]);
                        if (!isNaN(value)) {
                            if (currentData[groupVar][i] === groups[0]) {
                                group1Data.push(value);
                            } else if (currentData[groupVar][i] === groups[1]) {
                                group2Data.push(value);
                            }
                        }
                    }
                    
                    // Python으로 실제 t-test 수행
                    const pythonResult = await window.pyodide.runPythonAsync(`
                        import numpy as np
                        from scipy import stats
                        import json
                        
                        group1 = np.array(${JSON.stringify(group1Data)})
                        group2 = np.array(${JSON.stringify(group2Data)})
                        
                        # Independent t-test
                        if '${method.name}'.find('Welch') >= 0:
                            t_stat, p_value = stats.ttest_ind(group1, group2, equal_var=False)
                        else:
                            t_stat, p_value = stats.ttest_ind(group1, group2, equal_var=True)
                        
                        # 기술통계
                        mean1 = np.mean(group1)
                        mean2 = np.mean(group2)
                        std1 = np.std(group1, ddof=1)
                        std2 = np.std(group2, ddof=1)
                        n1 = len(group1)
                        n2 = len(group2)
                        
                        # 효과 크기 계산
                        pooled_std = np.sqrt(((n1-1)*std1**2 + (n2-1)*std2**2) / (n1+n2-2))
                        cohen_d = (mean1 - mean2) / pooled_std
                        
                        # 95% 신뢰구간
                        mean_diff = mean1 - mean2
                        se_diff = pooled_std * np.sqrt(1/n1 + 1/n2)
                        df = n1 + n2 - 2
                        t_crit = stats.t.ppf(0.975, df)
                        ci_lower = mean_diff - t_crit * se_diff
                        ci_upper = mean_diff + t_crit * se_diff
                        
                        result = {
                            "t_statistic": float(t_stat),
                            "p_value": float(p_value),
                            "df": int(df),
                            "mean1": float(mean1),
                            "mean2": float(mean2),
                            "std1": float(std1),
                            "std2": float(std2),
                            "n1": int(n1),
                            "n2": int(n2),
                            "cohen_d": float(cohen_d),
                            "ci_lower": float(ci_lower),
                            "ci_upper": float(ci_upper),
                            "mean_diff": float(mean_diff)
                        }
                        json.dumps(result)
                    `);
                    
                    const stats = JSON.parse(pythonResult);
                    
                    result.statistics = {
                        tStatistic: stats.t_statistic,
                        df: stats.df,
                        pValue: stats.p_value,
                        group1: { name: groups[0], n: stats.n1, mean: stats.mean1, std: stats.std1 },
                        group2: { name: groups[1], n: stats.n2, mean: stats.mean2, std: stats.std2 },
                        meanDifference: Math.abs(stats.mean_diff),
                        cohensD: Math.abs(stats.cohen_d),
                        confidenceInterval: [stats.ci_lower, stats.ci_upper]
                    };
                    
                    result.interpretation = stats.p_value < 0.05 ? 
                        `두 그룹 간 유의미한 차이가 있습니다 (t=${stats.t_statistic.toFixed(3)}, p=${stats.p_value.toFixed(4)} < 0.05). ${groups[0]}의 평균(${stats.mean1.toFixed(2)})과 ${groups[1]}의 평균(${stats.mean2.toFixed(2)}) 간 차이는 통계적으로 유의합니다. 효과크기(Cohen's d): ${Math.abs(stats.cohen_d).toFixed(3)}` :
                        `두 그룹 간 유의미한 차이가 없습니다 (t=${stats.t_statistic.toFixed(3)}, p=${stats.p_value.toFixed(4)} > 0.05). ${groups[0]}과 ${groups[1]}의 평균 차이는 통계적으로 유의하지 않습니다.`;
                        
                } else if (method.type === 'one_way_anova' || method.name.includes('ANOVA')) {
                    // ANOVA (Pyodide 사용)
                    const dependentVar = numericColumns[0];
                    const groupVar = groupColumns[0];
                    const groups = [...new Set(currentData[groupVar])];
                    
                    // 그룹별 데이터 준비
                    const groupDataArrays = {};
                    for (const group of groups) {
                        groupDataArrays[group] = [];
                    }
                    
                    for (let i = 0; i < currentData[groupVar].length; i++) {
                        const value = parseFloat(currentData[dependentVar][i]);
                        const group = currentData[groupVar][i];
                        if (!isNaN(value) && groupDataArrays[group]) {
                            groupDataArrays[group].push(value);
                        }
                    }
                    
                    // Python으로 실제 ANOVA 수행
                    const pythonResult = await window.pyodide.runPythonAsync(`
                        import numpy as np
                        from scipy import stats
                        import json
                        
                        # 그룹 데이터
                        groups_data = ${JSON.stringify(groupDataArrays)}
                        group_names = list(groups_data.keys())
                        group_arrays = [np.array(groups_data[name]) for name in group_names]
                        
                        # One-way ANOVA
                        f_stat, p_value = stats.f_oneway(*group_arrays)
                        
                        # 각 그룹 통계
                        group_stats = {}
                        all_data = []
                        for name, data in groups_data.items():
                            arr = np.array(data)
                            all_data.extend(data)
                            group_stats[name] = {
                                "n": len(arr),
                                "mean": float(np.mean(arr)),
                                "std": float(np.std(arr, ddof=1)),
                                "variance": float(np.var(arr, ddof=1))
                            }
                        
                        # 전체 통계
                        all_data = np.array(all_data)
                        grand_mean = np.mean(all_data)
                        total_n = len(all_data)
                        
                        # SS 계산
                        ss_total = np.sum((all_data - grand_mean)**2)
                        ss_between = sum(group_stats[name]["n"] * (group_stats[name]["mean"] - grand_mean)**2 
                                        for name in group_names)
                        ss_within = ss_total - ss_between
                        
                        # 자유도
                        df_between = len(group_names) - 1
                        df_within = total_n - len(group_names)
                        
                        # MS 계산
                        ms_between = ss_between / df_between
                        ms_within = ss_within / df_within
                        
                        # 효과 크기
                        eta_squared = ss_between / ss_total
                        omega_squared = (ss_between - df_between * ms_within) / (ss_total + ms_within)
                        
                        result = {
                            "f_statistic": float(f_stat),
                            "p_value": float(p_value),
                            "df_between": int(df_between),
                            "df_within": int(df_within),
                            "ss_between": float(ss_between),
                            "ss_within": float(ss_within),
                            "ss_total": float(ss_total),
                            "ms_between": float(ms_between),
                            "ms_within": float(ms_within),
                            "eta_squared": float(eta_squared),
                            "omega_squared": float(omega_squared),
                            "group_stats": group_stats,
                            "n_groups": len(group_names)
                        }
                        json.dumps(result)
                    `);
                    
                    const stats = JSON.parse(pythonResult);
                    
                    result.statistics = {
                        fStatistic: stats.f_statistic,
                        dfBetween: stats.df_between,
                        dfWithin: stats.df_within,
                        pValue: stats.p_value,
                        SSbetween: stats.ss_between,
                        SSwithin: stats.ss_within,
                        SStotal: stats.ss_total,
                        MSbetween: stats.ms_between,
                        MSwithin: stats.ms_within,
                        groups: stats.group_stats,
                        etaSquared: stats.eta_squared,
                        omegaSquared: stats.omega_squared
                    };
                    
                    result.interpretation = stats.p_value < 0.05 ?
                        `그룹 간 유의미한 차이가 있습니다 (F(${stats.df_between},${stats.df_within})=${stats.f_statistic.toFixed(3)}, p=${stats.p_value.toFixed(4)} < 0.05). 적어도 하나의 그룹 평균이 다른 그룹과 유의하게 다릅니다. 효과크기(η²): ${stats.eta_squared.toFixed(3)}` :
                        `그룹 간 유의미한 차이가 없습니다 (F(${stats.df_between},${stats.df_within})=${stats.f_statistic.toFixed(3)}, p=${stats.p_value.toFixed(4)} > 0.05). 모든 그룹의 평균이 통계적으로 유사합니다.`;
                        
                    // 사후분석 필요 여부
                    if (stats.p_value < 0.05 && stats.n_groups > 2) {
                        result.postHoc = {
                            method: analysisResults.assumptions?.homogeneity ? 'Tukey HSD' : 'Games-Howell',
                            comparisons: [],
                            note: '사후분석이 필요합니다 (3개 이상 그룹에서 유의한 차이 발견)'
                        };
                    }
                    
                } else if (method.type === 'mann_whitney' || method.type === 'kruskal_wallis') {
                    // 비모수 검정
                    result = await performNonParametricAnalysis(method, validation);
                } else {
                    // 기본 기술통계
                    result.statistics = {
                        description: '기술통계 분석'
                    };
                    result.interpretation = '데이터의 기본 통계량을 계산했습니다.';
                }
                
            } catch (error) {
                console.error('Statistical analysis error:', error);
                // 오류 시 fallback 함수 사용
                return performStatisticalAnalysisFallback();
            }
            
            return result;
        }
        
        // Fallback 함수 (Pyodide 없을 때 사용)
        function performStatisticalAnalysisFallback() {
            console.log('Using fallback statistical analysis');
            // 기존의 간단한 계산 로직 (필요시)
            return {
                method: 'Fallback Analysis',
                timestamp: new Date().toISOString(),
                statistics: {
                    note: 'Pyodide를 로드할 수 없어 간단한 분석만 제공됩니다.'
                },
                interpretation: 'Python 환경을 로드하지 못해 제한된 분석 결과를 제공합니다.'
            };
        }
        
        // 비모수 검정 수행
        async function performNonParametricAnalysis(method, validation) {
            if (!window.pyodide || !pyodideReady) {
                return performStatisticalAnalysisFallback();
            }
            
            const numericColumns = validation.numericColumns || [];
            const groupColumns = validation.groupColumns || [];
            
            let result = {
                method: method.name,
                timestamp: new Date().toISOString(),
                data: {},
                statistics: {},
                interpretation: '',
                postHoc: null
            };
            
            try {
                if (method.type === 'mann_whitney') {
                    // Mann-Whitney U test
                    const dependentVar = numericColumns[0];
                    const groupVar = groupColumns[0];
                    const groups = [...new Set(currentData[groupVar])];
                    
                    // 그룹별 데이터 분리
                    const group1Data = [];
                    const group2Data = [];
                    for (let i = 0; i < currentData[groupVar].length; i++) {
                        const value = parseFloat(currentData[dependentVar][i]);
                        if (!isNaN(value)) {
                            if (currentData[groupVar][i] === groups[0]) {
                                group1Data.push(value);
                            } else if (currentData[groupVar][i] === groups[1]) {
                                group2Data.push(value);
                            }
                        }
                    }
                    
                    const pythonResult = await window.pyodide.runPythonAsync(`
                        import numpy as np
                        from scipy import stats
                        import json
                        
                        group1 = np.array(${JSON.stringify(group1Data)})
                        group2 = np.array(${JSON.stringify(group2Data)})
                        
                        # Mann-Whitney U test
                        u_stat, p_value = stats.mannwhitneyu(group1, group2, alternative='two-sided')
                        
                        # 중앙값 계산
                        median1 = np.median(group1)
                        median2 = np.median(group2)
                        
                        # 순위 합
                        combined = np.concatenate([group1, group2])
                        ranks = stats.rankdata(combined)
                        rank_sum1 = np.sum(ranks[:len(group1)])
                        rank_sum2 = np.sum(ranks[len(group1):])
                        
                        # 효과 크기 (r = Z / sqrt(N))
                        n = len(group1) + len(group2)
                        z_stat = stats.norm.ppf(p_value / 2) if p_value < 1 else 0
                        effect_size = abs(z_stat) / np.sqrt(n)
                        
                        result = {
                            "u_statistic": float(u_stat),
                            "p_value": float(p_value),
                            "median1": float(median1),
                            "median2": float(median2),
                            "n1": len(group1),
                            "n2": len(group2),
                            "rank_sum1": float(rank_sum1),
                            "rank_sum2": float(rank_sum2),
                            "effect_size": float(effect_size)
                        }
                        json.dumps(result)
                    `);
                    
                    const stats = JSON.parse(pythonResult);
                    
                    result.statistics = {
                        uStatistic: stats.u_statistic,
                        pValue: stats.p_value,
                        group1: { name: groups[0], n: stats.n1, median: stats.median1, rankSum: stats.rank_sum1 },
                        group2: { name: groups[1], n: stats.n2, median: stats.median2, rankSum: stats.rank_sum2 },
                        effectSize: stats.effect_size
                    };
                    
                    result.interpretation = stats.p_value < 0.05 ?
                        `두 그룹 간 유의미한 차이가 있습니다 (U=${stats.u_statistic.toFixed(1)}, p=${stats.p_value.toFixed(4)} < 0.05). ${groups[0]}의 중앙값(${stats.median1.toFixed(2)})과 ${groups[1]}의 중앙값(${stats.median2.toFixed(2)}) 간 차이는 통계적으로 유의합니다.` :
                        `두 그룹 간 유의미한 차이가 없습니다 (U=${stats.u_statistic.toFixed(1)}, p=${stats.p_value.toFixed(4)} > 0.05).`;
                        
                } else if (method.type === 'kruskal_wallis') {
                    // Kruskal-Wallis test
                    const dependentVar = numericColumns[0];
                    const groupVar = groupColumns[0];
                    const groups = [...new Set(currentData[groupVar])];
                    
                    // 그룹별 데이터 준비
                    const groupDataArrays = {};
                    for (const group of groups) {
                        groupDataArrays[group] = [];
                    }
                    
                    for (let i = 0; i < currentData[groupVar].length; i++) {
                        const value = parseFloat(currentData[dependentVar][i]);
                        const group = currentData[groupVar][i];
                        if (!isNaN(value) && groupDataArrays[group]) {
                            groupDataArrays[group].push(value);
                        }
                    }
                    
                    const pythonResult = await window.pyodide.runPythonAsync(`
                        import numpy as np
                        from scipy import stats
                        import json
                        
                        # 그룹 데이터
                        groups_data = ${JSON.stringify(groupDataArrays)}
                        group_names = list(groups_data.keys())
                        group_arrays = [np.array(groups_data[name]) for name in group_names]
                        
                        # Kruskal-Wallis test
                        h_stat, p_value = stats.kruskal(*group_arrays)
                        
                        # 각 그룹 통계
                        group_stats = {}
                        for name, data in groups_data.items():
                            arr = np.array(data)
                            group_stats[name] = {
                                "n": len(arr),
                                "median": float(np.median(arr)),
                                "iqr": float(np.percentile(arr, 75) - np.percentile(arr, 25)),
                                "mean_rank": float(stats.rankdata(np.concatenate(group_arrays))[
                                    sum(len(groups_data[n]) for n in group_names[:group_names.index(name)]):
                                    sum(len(groups_data[n]) for n in group_names[:group_names.index(name)+1])
                                ].mean())
                            }
                        
                        # 효과 크기 (epsilon squared)
                        n_total = sum(len(arr) for arr in group_arrays)
                        epsilon_squared = (h_stat - len(group_names) + 1) / (n_total - len(group_names))
                        
                        result = {
                            "h_statistic": float(h_stat),
                            "p_value": float(p_value),
                            "df": len(group_names) - 1,
                            "group_stats": group_stats,
                            "n_groups": len(group_names),
                            "epsilon_squared": float(epsilon_squared) if epsilon_squared > 0 else 0
                        }
                        json.dumps(result)
                    `);
                    
                    const stats = JSON.parse(pythonResult);
                    
                    result.statistics = {
                        hStatistic: stats.h_statistic,
                        df: stats.df,
                        pValue: stats.p_value,
                        groups: stats.group_stats,
                        epsilonSquared: stats.epsilon_squared
                    };
                    
                    result.interpretation = stats.p_value < 0.05 ?
                        `그룹 간 유의미한 차이가 있습니다 (H=${stats.h_statistic.toFixed(3)}, p=${stats.p_value.toFixed(4)} < 0.05). 적어도 하나의 그룹이 다른 그룹과 유의하게 다릅니다.` :
                        `그룹 간 유의미한 차이가 없습니다 (H=${stats.h_statistic.toFixed(3)}, p=${stats.p_value.toFixed(4)} > 0.05).`;
                        
                    // 사후분석 필요 여부
                    if (stats.p_value < 0.05 && stats.n_groups > 2) {
                        result.postHoc = {
                            method: "Dunn's test",
                            comparisons: [],
                            note: '비모수 사후분석이 필요합니다 (3개 이상 그룹에서 유의한 차이 발견)'
                        };
                    }
                }
                
            } catch (error) {
                console.error('Non-parametric analysis error:', error);
                return performStatisticalAnalysisFallback();
            }
            
            return result;
        }
        
        function displayAnalysisProgress(analysis) {
            const progressEl = document.getElementById('analysisProgress');
            if (progressEl) {
                progressEl.textContent = analysis.status === 'running' ? 
                    '통계 분석을 수행하고 있습니다...' : 
                    '분석 완료';
            }
        }
        
        // 결과 표시
        function displayResults() {
            if (!analysisResults.final) return;
            
            const result = analysisResults.final;
            const stats = result.statistics;
            
            let html = `
                <div class="space-y-4">
                    <!-- 주요 결과 -->
                    <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
                        <h4 class="font-semibold text-blue-800 mb-3">📊 통계 분석 결과</h4>
                        <div class="text-lg font-medium mb-2">${result.method}</div>
            `;
            
            // t-검정 결과 표시
            if (stats.tStatistic !== undefined) {
                html += `
                        <div class="grid grid-cols-2 gap-4 mb-3">
                            <div>
                                <div class="text-sm text-gray-600">t-통계량</div>
                                <div class="font-semibold">${stats.tStatistic.toFixed(3)}</div>
                            </div>
                            <div>
                                <div class="text-sm text-gray-600">자유도</div>
                                <div class="font-semibold">${stats.df}</div>
                            </div>
                            <div>
                                <div class="text-sm text-gray-600">p-값</div>
                                <div class="font-semibold ${stats.pValue < 0.05 ? 'text-red-600' : 'text-green-600'}">
                                    ${stats.pValue.toFixed(4)} ${stats.pValue < 0.05 ? '(유의)' : '(비유의)'}
                                </div>
                            </div>
                            <div>
                                <div class="text-sm text-gray-600">효과크기 (Cohen's d)</div>
                                <div class="font-semibold">${stats.cohensD.toFixed(3)}</div>
                            </div>
                        </div>
                        <div class="bg-white p-3 rounded">
                            <div class="text-sm font-medium mb-2">그룹별 통계</div>
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                <div>
                                    <span class="font-medium">${stats.group1.name}:</span>
                                    n=${stats.group1.n}, M=${stats.group1.mean.toFixed(2)}, SD=${stats.group1.std.toFixed(2)}
                                </div>
                                <div>
                                    <span class="font-medium">${stats.group2.name}:</span>
                                    n=${stats.group2.n}, M=${stats.group2.mean.toFixed(2)}, SD=${stats.group2.std.toFixed(2)}
                                </div>
                            </div>
                            <div class="mt-2">
                                <span class="font-medium">평균 차이:</span> ${stats.meanDifference.toFixed(2)}
                            </div>
                        </div>
                `;
            }
            // ANOVA 결과 표시
            else if (stats.fStatistic !== undefined) {
                html += `
                        <div class="grid grid-cols-3 gap-3 mb-3">
                            <div>
                                <div class="text-sm text-gray-600">F-통계량</div>
                                <div class="font-semibold">${stats.fStatistic.toFixed(3)}</div>
                            </div>
                            <div>
                                <div class="text-sm text-gray-600">자유도</div>
                                <div class="font-semibold">${stats.dfBetween}, ${stats.dfWithin}</div>
                            </div>
                            <div>
                                <div class="text-sm text-gray-600">p-값</div>
                                <div class="font-semibold ${stats.pValue < 0.05 ? 'text-red-600' : 'text-green-600'}">
                                    ${stats.pValue.toFixed(4)} ${stats.pValue < 0.05 ? '(유의)' : '(비유의)'}
                                </div>
                            </div>
                        </div>
                        <div class="bg-white p-3 rounded">
                            <div class="text-sm font-medium mb-2">분산분석표</div>
                            <table class="text-xs w-full">
                                <tr class="border-b">
                                    <th class="text-left">요인</th>
                                    <th class="text-right">SS</th>
                                    <th class="text-right">df</th>
                                    <th class="text-right">MS</th>
                                    <th class="text-right">F</th>
                                </tr>
                                <tr>
                                    <td>집단 간</td>
                                    <td class="text-right">${stats.SSbetween.toFixed(2)}</td>
                                    <td class="text-right">${stats.dfBetween}</td>
                                    <td class="text-right">${stats.MSbetween.toFixed(2)}</td>
                                    <td class="text-right">${stats.fStatistic.toFixed(3)}</td>
                                </tr>
                                <tr>
                                    <td>집단 내</td>
                                    <td class="text-right">${stats.SSwithin.toFixed(2)}</td>
                                    <td class="text-right">${stats.dfWithin}</td>
                                    <td class="text-right">${stats.MSwithin.toFixed(2)}</td>
                                    <td class="text-right">-</td>
                                </tr>
                            </table>
                            <div class="mt-2">
                                <span class="font-medium">효과크기 (η²):</span> ${stats.etaSquared.toFixed(3)}
                            </div>
                        </div>
                        ${stats.groups ? `
                        <div class="bg-white p-3 rounded mt-2">
                            <div class="text-sm font-medium mb-2">그룹별 기술통계</div>
                            <div class="space-y-1 text-sm">
                                ${Object.entries(stats.groups).map(([name, stat]) => `
                                    <div><span class="font-medium">${name}:</span> n=${stat.n}, M=${stat.mean.toFixed(2)}, SD=${Math.sqrt(stat.variance).toFixed(2)}</div>
                                `).join('')}
                            </div>
                        </div>
                        ` : ''}
                `;
            }
            
            html += `
                    </div>
                    
                    <!-- 해석 -->
                    <div class="bg-green-50 p-4 rounded-lg border border-green-200">
                        <h5 class="font-semibold text-green-800 mb-2">💡 결과 해석</h5>
                        <p class="text-sm text-green-700">${result.interpretation}</p>
                    </div>
                    
                    <!-- 사후분석 필요 여부 -->
                    ${result.postHoc ? `
                    <div class="bg-yellow-50 p-4 rounded-lg border border-yellow-200">
                        <h5 class="font-semibold text-yellow-800 mb-2">📌 사후분석</h5>
                        <p class="text-sm text-yellow-700">${result.postHoc.note}</p>
                        <p class="text-xs text-yellow-600 mt-1">추천 방법: ${result.postHoc.method}</p>
                        <button onclick="performPostHocAnalysis()" class="mt-2 px-3 py-1 bg-yellow-600 text-white text-sm rounded hover:bg-yellow-700">
                            사후분석 실행
                        </button>
                    </div>
                    ` : ''}
                    
                    <!-- 추가 분석 옵션 -->
                    <div id="nextAnalysisOptions" class="bg-indigo-50 p-4 rounded-lg border border-indigo-200">
                        <h5 class="font-semibold text-indigo-800 mb-3">🔍 추가 분석 옵션</h5>
                        <div id="analysisOptionsContent"></div>
                    </div>
                    
                    <!-- 시각화 플레이스홀더 -->
                    <div class="bg-gray-50 p-4 rounded-lg">
                        <h5 class="font-semibold mb-2">📈 시각화</h5>
                        <div class="h-48 bg-white rounded flex items-center justify-center text-gray-400">
                            [차트가 여기에 표시됩니다]
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('analysisResults').innerHTML = html;
            
            // 추가 분석 옵션 생성
            generateNextAnalysisOptions(result);
            
            // 내보내기 버튼 표시
            const exportBtn = document.getElementById('exportBtn');
            if (exportBtn) {
                exportBtn.style.display = 'inline-block';
            }
            
            // 설명 박스 표시
            document.getElementById('step6Explanation').classList.remove('hidden');
            
            // 분석 결과를 로컬 스토리지에 저장 (추후 내보내기용)
            saveAnalysisRecord(result);
        }
        
        // 효과 크기 계산 함수들
        function calculateEffectSizes(data, groups, testType) {
            const effectSizes = {};
            
            if (testType === 'ttest' || testType === 'paired_test') {
                // Cohen's d 계산
                const group1 = data.filter((_, i) => groups[i] === groups[0]);
                const group2 = data.filter((_, i) => groups[i] !== groups[0]);
                
                const mean1 = group1.reduce((a, b) => a + b, 0) / group1.length;
                const mean2 = group2.reduce((a, b) => a + b, 0) / group2.length;
                
                const var1 = group1.reduce((a, b) => a + Math.pow(b - mean1, 2), 0) / (group1.length - 1);
                const var2 = group2.reduce((a, b) => a + Math.pow(b - mean2, 2), 0) / (group2.length - 1);
                
                // Pooled standard deviation
                const pooledSD = Math.sqrt(((group1.length - 1) * var1 + (group2.length - 1) * var2) / 
                                          (group1.length + group2.length - 2));
                
                effectSizes.cohensD = (mean1 - mean2) / pooledSD;
                
                // Hedges' g (소표본 보정 - 올바른 공식)
                const df = group1.length + group2.length - 2;
                const correctionFactor = 1 - (3 / (4 * df - 1));
                effectSizes.hedgesG = effectSizes.cohensD * correctionFactor;
                
                // Glass's delta
                effectSizes.glassDelta = (mean1 - mean2) / Math.sqrt(var2);
                
                // 해석
                const d = Math.abs(effectSizes.cohensD);
                effectSizes.interpretation = 
                    d < 0.2 ? '매우 작은 효과' :
                    d < 0.5 ? '작은 효과' :
                    d < 0.8 ? '중간 효과' : '큰 효과';
                    
            } else if (testType === 'anova' || testType === 'kruskal') {
                // Eta-squared 계산 (ANOVA)
                const grandMean = data.reduce((a, b) => a + b, 0) / data.length;
                const totalSS = data.reduce((a, b) => a + Math.pow(b - grandMean, 2), 0);
                
                const groupMeans = {};
                const groupCounts = {};
                for (let i = 0; i < data.length; i++) {
                    const group = groups[i];
                    if (!groupMeans[group]) {
                        groupMeans[group] = [];
                        groupCounts[group] = 0;
                    }
                    groupMeans[group].push(data[i]);
                    groupCounts[group]++;
                }
                
                let betweenSS = 0;
                for (const [group, values] of Object.entries(groupMeans)) {
                    const groupMean = values.reduce((a, b) => a + b, 0) / values.length;
                    betweenSS += values.length * Math.pow(groupMean - grandMean, 2);
                }
                
                effectSizes.etaSquared = betweenSS / totalSS;
                effectSizes.partialEtaSquared = betweenSS / (betweenSS + (totalSS - betweenSS));
                
                // Omega-squared (더 정확한 효과 크기)
                const dfBetween = Object.keys(groupMeans).length - 1;
                const dfWithin = data.length - Object.keys(groupMeans).length;
                const msBetween = betweenSS / dfBetween;
                const msWithin = (totalSS - betweenSS) / dfWithin;
                
                effectSizes.omegaSquared = (betweenSS - dfBetween * msWithin) / (totalSS + msWithin);
                
                // 해석
                const eta = effectSizes.etaSquared;
                effectSizes.interpretation = 
                    eta < 0.01 ? '매우 작은 효과' :
                    eta < 0.06 ? '작은 효과' :
                    eta < 0.14 ? '중간 효과' : '큰 효과';
            }
            
            return effectSizes;
        }
        
        // p값 보정 방법들
        function adjustPValues(pValues, method = 'bonferroni') {
            const n = pValues.length;
            let adjusted = [...pValues];
            
            switch(method) {
                case 'bonferroni':
                    // Bonferroni 보정
                    adjusted = pValues.map(p => Math.min(p * n, 1));
                    break;
                    
                case 'holm':
                    // Holm-Bonferroni 보정 (단계적 방법)
                    const sorted = pValues.map((p, i) => ({p, i})).sort((a, b) => a.p - b.p);
                    for (let i = 0; i < sorted.length; i++) {
                        sorted[i].adjusted = Math.min(sorted[i].p * (n - i), 1);
                        // 이전 값보다 작지 않도록 보장
                        if (i > 0 && sorted[i].adjusted < sorted[i-1].adjusted) {
                            sorted[i].adjusted = sorted[i-1].adjusted;
                        }
                    }
                    // 원래 순서로 복원
                    sorted.forEach(item => adjusted[item.i] = item.adjusted);
                    break;
                    
                case 'hochberg':
                    // Hochberg 보정 (역순 방법)
                    const sortedDesc = pValues.map((p, i) => ({p, i})).sort((a, b) => b.p - a.p);
                    for (let i = 0; i < sortedDesc.length; i++) {
                        sortedDesc[i].adjusted = Math.min(sortedDesc[i].p * (i + 1), 1);
                        // 이전 값보다 크지 않도록 보장
                        if (i > 0 && sortedDesc[i].adjusted > sortedDesc[i-1].adjusted) {
                            sortedDesc[i].adjusted = sortedDesc[i-1].adjusted;
                        }
                    }
                    sortedDesc.forEach(item => adjusted[item.i] = item.adjusted);
                    break;
                    
                case 'bh': // Benjamini-Hochberg
                case 'fdr':
                    // False Discovery Rate 제어
                    const sortedBH = pValues.map((p, i) => ({p, i})).sort((a, b) => a.p - b.p);
                    for (let i = sortedBH.length - 1; i >= 0; i--) {
                        const adj = Math.min(sortedBH[i].p * n / (i + 1), 1);
                        sortedBH[i].adjusted = i === sortedBH.length - 1 ? adj : 
                                               Math.min(adj, sortedBH[i + 1].adjusted);
                    }
                    sortedBH.forEach(item => adjusted[item.i] = item.adjusted);
                    break;
                    
                default:
                    // 보정 없음
                    break;
            }
            
            return adjusted;
        }
        
        // 검정력 계산 (post-hoc)
        function calculatePower(effectSize, sampleSize, alpha = 0.05) {
            // 간단한 근사치 계산 (Cohen's d 기준)
            const ncp = effectSize * Math.sqrt(sampleSize / 2); // Non-centrality parameter
            const criticalZ = 1.96; // alpha = 0.05일 때
            
            // 비중심 t-분포의 누적분포함수 근사
            // 정확한 계산은 scipy.stats 필요
            const power = 1 - normalCDF((criticalZ - ncp) / 1);
            
            return {
                power: power,
                interpretation: power < 0.5 ? '매우 낮은 검정력' :
                               power < 0.8 ? '낮은 검정력' :
                               power < 0.95 ? '적절한 검정력' : '높은 검정력',
                recommendedN: power < 0.8 ? Math.ceil(sampleSize * Math.pow(0.8/power, 2)) : null
            };
        }
        
        // 정규분포 CDF 근사
        function normalCDF(z) {
            const a1 = 0.254829592;
            const a2 = -0.284496736;
            const a3 = 1.421413741;
            const a4 = -1.453152027;
            const a5 = 1.061405429;
            const p = 0.3275911;
            
            const sign = z >= 0 ? 1 : -1;
            z = Math.abs(z);
            
            const t = 1.0 / (1.0 + p * z);
            const t2 = t * t;
            const t3 = t2 * t;
            const t4 = t3 * t;
            const t5 = t4 * t;
            
            const y = 1.0 - (((((a5 * t5 + a4 * t4) + a3 * t3) + a2 * t2) + a1 * t) * Math.exp(-z * z / 2));
            
            return 0.5 * (1 + sign * y);
        }
        
        // 추가 분석 옵션 생성
        function generateNextAnalysisOptions(result) {
            const stats = result.statistics;
            let optionsHtml = '<div class="space-y-3">';
            
            // p-값에 따른 옵션 제공
            if (stats.pValue < 0.05) {
                // 유의한 경우의 옵션
                optionsHtml += `
                    <div class="bg-white p-3 rounded border border-indigo-200">
                        <h6 class="font-medium text-indigo-700 mb-2">✅ 유의한 차이 발견 - 다음 단계</h6>
                        <div class="space-y-2 text-sm">
                `;
                
                // 효과 크기 분석
                optionsHtml += `
                    <label class="flex items-start cursor-pointer hover:bg-indigo-50 p-2 rounded">
                        <input type="checkbox" class="mt-1 mr-2" value="effectSize">
                        <div>
                            <div class="font-medium">효과 크기 상세 분석</div>
                            <div class="text-xs text-gray-600">Cohen's d, Glass's delta, 신뢰구간 계산</div>
                        </div>
                    </label>
                `;
                
                // 검정력 분석
                optionsHtml += `
                    <label class="flex items-start cursor-pointer hover:bg-indigo-50 p-2 rounded">
                        <input type="checkbox" class="mt-1 mr-2" value="power">
                        <div>
                            <div class="font-medium">사후 검정력 분석</div>
                            <div class="text-xs text-gray-600">관찰된 효과에 대한 검정력 계산</div>
                        </div>
                    </label>
                `;
                
                // 예측 모델
                if (stats.groups && Object.keys(stats.groups).length >= 2) {
                    optionsHtml += `
                        <label class="flex items-start cursor-pointer hover:bg-indigo-50 p-2 rounded">
                            <input type="checkbox" class="mt-1 mr-2" value="prediction">
                            <div>
                                <div class="font-medium">예측 모델 구축</div>
                                <div class="text-xs text-gray-600">그룹 소속 예측을 위한 판별분석</div>
                            </div>
                        </label>
                    `;
                }
                
                optionsHtml += '</div></div>';
                
            } else {
                // 유의하지 않은 경우의 옵션
                optionsHtml += `
                    <div class="bg-white p-3 rounded border border-indigo-200">
                        <h6 class="font-medium text-indigo-700 mb-2">❌ 유의한 차이 없음 - 대안 분석</h6>
                        <div class="space-y-2 text-sm">
                `;
                
                // 동등성 검정
                optionsHtml += `
                    <label class="flex items-start cursor-pointer hover:bg-indigo-50 p-2 rounded">
                        <input type="checkbox" class="mt-1 mr-2" value="equivalence">
                        <div>
                            <div class="font-medium">동등성 검정 (TOST)</div>
                            <div class="text-xs text-gray-600">그룹 간 실제적 동등성 확인</div>
                        </div>
                    </label>
                `;
                
                // 검정력 분석
                optionsHtml += `
                    <label class="flex items-start cursor-pointer hover:bg-indigo-50 p-2 rounded">
                        <input type="checkbox" class="mt-1 mr-2" value="powerCalc">
                        <div>
                            <div class="font-medium">필요 표본 크기 계산</div>
                            <div class="text-xs text-gray-600">원하는 검정력 달성을 위한 n 계산</div>
                        </div>
                    </label>
                `;
                
                // 베이지안 분석
                optionsHtml += `
                    <label class="flex items-start cursor-pointer hover:bg-indigo-50 p-2 rounded">
                        <input type="checkbox" class="mt-1 mr-2" value="bayesian">
                        <div>
                            <div class="font-medium">베이지안 분석</div>
                            <div class="text-xs text-gray-600">베이즈 인자를 통한 귀무가설 지지 정도 확인</div>
                        </div>
                    </label>
                `;
                
                optionsHtml += '</div></div>';
            }
            
            // 일반 옵션 (항상 제공)
            optionsHtml += `
                <div class="bg-white p-3 rounded border border-indigo-200">
                    <h6 class="font-medium text-indigo-700 mb-2">📊 추가 탐색 옵션</h6>
                    <div class="space-y-2 text-sm">
                        <label class="flex items-start cursor-pointer hover:bg-indigo-50 p-2 rounded">
                            <input type="checkbox" class="mt-1 mr-2" value="outlier">
                            <div>
                                <div class="font-medium">이상치 영향 분석</div>
                                <div class="text-xs text-gray-600">이상치 제거 전후 결과 비교</div>
                            </div>
                        </label>
                        <label class="flex items-start cursor-pointer hover:bg-indigo-50 p-2 rounded">
                            <input type="checkbox" class="mt-1 mr-2" value="bootstrap">
                            <div>
                                <div class="font-medium">부트스트랩 신뢰구간</div>
                                <div class="text-xs text-gray-600">비모수적 신뢰구간 추정</div>
                            </div>
                        </label>
                        <label class="flex items-start cursor-pointer hover:bg-indigo-50 p-2 rounded">
                            <input type="checkbox" class="mt-1 mr-2" value="sensitivity">
                            <div>
                                <div class="font-medium">민감도 분석</div>
                                <div class="text-xs text-gray-600">다른 검정 방법 적용 시 결과 비교</div>
                            </div>
                        </label>
                    </div>
                </div>
            `;
            
            optionsHtml += `
                <button onclick="executeSelectedAnalyses()" class="w-full mt-3 px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700">
                    선택한 분석 실행
                </button>
            </div>`;
            
            document.getElementById('analysisOptionsContent').innerHTML = optionsHtml;
        }
        
        // 사후분석 실행
        async function performPostHocAnalysis() {
            const result = analysisResults.final;
            if (!result.postHoc) {
                alert('사후분석이 필요하지 않습니다.');
                return;
            }
            
            // 사후분석 준비
            const postHocResult = {
                method: result.postHoc.method,
                comparisons: [],
                timestamp: new Date().toISOString()
            };
            
            // Pyodide가 준비되었는지 확인
            if (!window.pyodide || !pyodideReady) {
                console.warn('Pyodide not ready for post-hoc analysis');
                // Fallback 처리
                displayPostHocResults(postHocResult);
                return;
            }
            
            try {
                // 데이터 준비
                const validation = analysisResults.validation;
                const numericColumns = validation.numericColumns || [];
                const groupColumns = validation.groupColumns || [];
                const dependentVar = numericColumns[0];
                const groupVar = groupColumns[0];
                const groups = [...new Set(currentData[groupVar])];
                
                // 그룹별 데이터 준비
                const groupDataArrays = {};
                for (const group of groups) {
                    groupDataArrays[group] = [];
                }
                
                for (let i = 0; i < currentData[groupVar].length; i++) {
                    const value = parseFloat(currentData[dependentVar][i]);
                    const group = currentData[groupVar][i];
                    if (!isNaN(value) && groupDataArrays[group]) {
                        groupDataArrays[group].push(value);
                    }
                }
                
                // Python으로 실제 사후분석 수행
                const pythonResult = await window.pyodide.runPythonAsync(`
                    import numpy as np
                    from scipy import stats
                    import json
                    from itertools import combinations
                    
                    # 그룹 데이터
                    groups_data = ${JSON.stringify(groupDataArrays)}
                    group_names = list(groups_data.keys())
                    group_arrays = [np.array(groups_data[name]) for name in group_names]
                    method = "${result.postHoc.method}"
                    
                    comparisons = []
                    
                    if method == "Tukey HSD":
                        # Tukey HSD 수동 구현 (scipy 0.24.1에는 없음)
                        # MSE 계산
                        all_data = np.concatenate(group_arrays)
                        grand_mean = np.mean(all_data)
                        n_total = len(all_data)
                        k = len(group_names)
                        
                        # Within-group variance
                        ss_within = sum((len(arr)-1) * np.var(arr, ddof=1) for arr in group_arrays)
                        df_within = n_total - k
                        mse = ss_within / df_within
                        
                        # 모든 쌍별 비교
                        for i, j in combinations(range(k), 2):
                            name1, name2 = group_names[i], group_names[j]
                            group1, group2 = group_arrays[i], group_arrays[j]
                            n1, n2 = len(group1), len(group2)
                            mean1, mean2 = np.mean(group1), np.mean(group2)
                            
                            # Tukey's HSD
                            mean_diff = mean1 - mean2
                            se = np.sqrt(mse * (1/n1 + 1/n2) / 2)
                            q_stat = abs(mean_diff) / se
                            
                            # Critical value (approximate)
                            # q_crit ≈ 2.8 for α=0.05, k=3, df=∞
                            # More accurate would require studentized range distribution
                            q_crit = 2.8 + 0.5 * (k - 3)  # 근사값
                            p_value = 0.01 if q_stat > q_crit else 0.10
                            
                            # 95% CI
                            margin = q_crit * se
                            ci_lower = mean_diff - margin
                            ci_upper = mean_diff + margin
                            
                            comparisons.append({
                                "group1": name1,
                                "group2": name2,
                                "meanDifference": float(abs(mean_diff)),
                                "pValue": float(p_value),
                                "significant": p_value < 0.05,
                                "confidenceInterval": [float(ci_lower), float(ci_upper)],
                                "qStatistic": float(q_stat)
                            })
                            
                    elif method == "Games-Howell":
                        # Games-Howell (unequal variances)
                        for i, j in combinations(range(len(group_names)), 2):
                            name1, name2 = group_names[i], group_names[j]
                            group1, group2 = group_arrays[i], group_arrays[j]
                            n1, n2 = len(group1), len(group2)
                            mean1, mean2 = np.mean(group1), np.mean(group2)
                            var1, var2 = np.var(group1, ddof=1), np.var(group2, ddof=1)
                            
                            # Games-Howell statistic
                            mean_diff = mean1 - mean2
                            se = np.sqrt(var1/n1 + var2/n2)
                            t_stat = abs(mean_diff) / se
                            
                            # Welch's degrees of freedom
                            df = (var1/n1 + var2/n2)**2 / ((var1/n1)**2/(n1-1) + (var2/n2)**2/(n2-1))
                            
                            # p-value (two-tailed)
                            p_value = 2 * (1 - stats.t.cdf(abs(t_stat), df))
                            
                            # 95% CI
                            t_crit = stats.t.ppf(0.975, df)
                            margin = t_crit * se
                            ci_lower = mean_diff - margin
                            ci_upper = mean_diff + margin
                            
                            comparisons.append({
                                "group1": name1,
                                "group2": name2,
                                "meanDifference": float(abs(mean_diff)),
                                "pValue": float(p_value),
                                "significant": p_value < 0.05,
                                "confidenceInterval": [float(ci_lower), float(ci_upper)],
                                "tStatistic": float(t_stat),
                                "df": float(df)
                            })
                            
                    elif method == "Bonferroni":
                        # Bonferroni correction
                        n_comparisons = len(list(combinations(group_names, 2)))
                        alpha_corrected = 0.05 / n_comparisons
                        
                        for i, j in combinations(range(len(group_names)), 2):
                            name1, name2 = group_names[i], group_names[j]
                            group1, group2 = group_arrays[i], group_arrays[j]
                            
                            # Regular t-test
                            t_stat, p_value = stats.ttest_ind(group1, group2)
                            
                            # Adjusted significance
                            p_adjusted = min(p_value * n_comparisons, 1.0)
                            
                            mean_diff = np.mean(group1) - np.mean(group2)
                            
                            comparisons.append({
                                "group1": name1,
                                "group2": name2,
                                "meanDifference": float(abs(mean_diff)),
                                "pValue": float(p_value),
                                "pAdjusted": float(p_adjusted),
                                "significant": p_adjusted < 0.05,
                                "tStatistic": float(t_stat)
                            })
                            
                    elif method == "Dunn's test":
                        # Dunn's test for Kruskal-Wallis follow-up
                        # Combine all data and rank
                        all_data = np.concatenate(group_arrays)
                        all_groups = []
                        for i, arr in enumerate(group_arrays):
                            all_groups.extend([group_names[i]] * len(arr))
                        
                        ranks = stats.rankdata(all_data)
                        
                        # Mean ranks for each group
                        mean_ranks = {}
                        for name in group_names:
                            group_ranks = [ranks[i] for i, g in enumerate(all_groups) if g == name]
                            mean_ranks[name] = np.mean(group_ranks)
                        
                        n = len(all_data)
                        
                        for i, j in combinations(range(len(group_names)), 2):
                            name1, name2 = group_names[i], group_names[j]
                            n1, n2 = len(group_arrays[i]), len(group_arrays[j])
                            
                            # Dunn's z-statistic
                            mean_rank_diff = mean_ranks[name1] - mean_ranks[name2]
                            se = np.sqrt((n * (n + 1) / 12) * (1/n1 + 1/n2))
                            z_stat = abs(mean_rank_diff) / se
                            
                            # p-value (two-tailed)
                            p_value = 2 * (1 - stats.norm.cdf(abs(z_stat)))
                            
                            comparisons.append({
                                "group1": name1,
                                "group2": name2,
                                "meanRankDifference": float(abs(mean_rank_diff)),
                                "pValue": float(p_value),
                                "significant": p_value < 0.05,
                                "zStatistic": float(z_stat)
                            })
                    
                    result = {
                        "method": method,
                        "comparisons": comparisons
                    }
                    json.dumps(result)
                `);
                
                const pythonData = JSON.parse(pythonResult);
                postHocResult.comparisons = pythonData.comparisons;
                
            } catch (error) {
                console.error('Post-hoc analysis error:', error);
            }
            
            // 결과 표시
            displayPostHocResults(postHocResult);
        }
        
        // 사후분석 결과 표시
        function displayPostHocResults(postHocResult) {
            let html = `
                <div class="mt-4 p-4 bg-orange-50 rounded-lg border border-orange-200">
                    <h5 class="font-semibold text-orange-800 mb-3">📊 사후분석 결과: ${postHocResult.method}</h5>
                    <table class="w-full text-sm">
                        <thead>
                            <tr class="border-b">
                                <th class="text-left">비교</th>
                                <th class="text-right">평균차</th>
                                <th class="text-right">p-값</th>
                                <th class="text-center">유의성</th>
                                <th class="text-right">95% CI</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            for (const comp of postHocResult.comparisons) {
                html += `
                    <tr class="border-b">
                        <td>${comp.group1} - ${comp.group2}</td>
                        <td class="text-right">${comp.meanDifference.toFixed(3)}</td>
                        <td class="text-right ${comp.significant ? 'text-red-600 font-semibold' : ''}">${comp.pValue.toFixed(4)}</td>
                        <td class="text-center">${comp.significant ? '✓' : '-'}</td>
                        <td class="text-right">[${comp.confidenceInterval[0].toFixed(2)}, ${comp.confidenceInterval[1].toFixed(2)}]</td>
                    </tr>
                `;
            }
            
            html += `
                        </tbody>
                    </table>
                    <p class="text-xs text-orange-600 mt-2">
                        * p-값은 다중비교에 대해 조정되었습니다 (${postHocResult.method} 방법)
                    </p>
                </div>
            `;
            
            // 기존 사후분석 섹션 뒤에 추가
            const postHocDiv = document.querySelector('.bg-yellow-50');
            if (postHocDiv) {
                postHocDiv.insertAdjacentHTML('afterend', html);
                postHocDiv.querySelector('button').disabled = true;
                postHocDiv.querySelector('button').textContent = '사후분석 완료';
            }
            
            // 결과 저장
            analysisResults.postHocAnalysis = postHocResult;
            saveAnalysisRecord(analysisResults);
        }
        
        // 선택된 추가 분석 실행
        function executeSelectedAnalyses() {
            const checkboxes = document.querySelectorAll('#analysisOptionsContent input[type="checkbox"]:checked');
            const selectedAnalyses = Array.from(checkboxes).map(cb => cb.value);
            
            if (selectedAnalyses.length === 0) {
                alert('실행할 분석을 선택해주세요.');
                return;
            }
            
            console.log('선택된 분석:', selectedAnalyses);
            alert(`다음 분석이 실행됩니다:\n${selectedAnalyses.join(', ')}\n\n(실제 구현은 추후 개발 예정)`);
        }
        
        // 분석 기록 저장
        function saveAnalysisRecord(data) {
            const record = {
                timestamp: new Date().toISOString(),
                data: currentData,
                validation: analysisResults.validation,
                assumptions: analysisResults.assumptions,
                method: analysisResults.method,
                results: data,
                postHoc: analysisResults.postHocAnalysis || null
            };
            
            // 로컬 스토리지에 저장
            const records = JSON.parse(localStorage.getItem('analysisRecords') || '[]');
            records.push(record);
            localStorage.setItem('analysisRecords', JSON.stringify(records));
            
            // 파일로도 자동 저장 (optional)
            downloadAnalysisReport(record);
        }
        
        // 분석 보고서 다운로드
        function downloadAnalysisReport(record) {
            const report = `
# 통계 분석 보고서
생성 시간: ${new Date(record.timestamp).toLocaleString('ko-KR')}

## 1. 데이터 검증
- 행 수: ${record.validation.rows}
- 열 수: ${record.validation.columns}
- 연속형 변수: ${record.validation.numericColumns.join(', ')}
- 그룹 변수: ${record.validation.groupColumns.join(', ')}
- 품질 문제: ${record.validation.issues.length === 0 ? '없음' : record.validation.issues.join(', ')}

## 2. 통계적 가정 검정
### 정규성 검정
${record.assumptions.normality.map(n => `- ${n.variable}: ${n.interpretation} (p=${n.pValue.toFixed(4)})`).join('\n')}

### 등분산성 검정
${record.assumptions.homogeneity.map(h => `- ${h.variable} by ${h.groupVariable}: ${h.interpretation}`).join('\n') || '해당 없음'}

## 3. 분석 방법
- 선택된 방법: ${record.method.primary.name}
- 선택 이유: ${record.method.reasoning.join(', ')}

## 4. 분석 결과
- 검정 통계량: ${JSON.stringify(record.results.statistics, null, 2)}
- 해석: ${record.results.interpretation}

## 5. 사후분석
${record.postHoc ? JSON.stringify(record.postHoc, null, 2) : '해당 없음'}

---
이 보고서는 자동으로 생성되었습니다.
            `;
            
            // 콘솔에 출력 (실제로는 파일 다운로드로 구현)
            console.log('=== 분석 보고서 ===');
            console.log(report);
            
            // 실제 파일 다운로드는 나중에 구현
            // const blob = new Blob([report], { type: 'text/markdown' });
            // const url = URL.createObjectURL(blob);
            // const a = document.createElement('a');
            // a.href = url;
            // a.download = `analysis_report_${Date.now()}.md`;
            // a.click();
        }
        
        // 결과 내보내기
        function exportResults() {
            // 내보내기 옵션 모달 표시
            showExportOptions();
        }
        
        // 내보내기 옵션 모달 표시
        function showExportOptions() {
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            modal.id = 'exportModal';
            
            modal.innerHTML = `
                <div class="bg-white rounded-lg p-6 max-w-md">
                    <h3 class="text-xl font-bold mb-4">결과 내보내기</h3>
                    <p class="text-sm text-gray-600 mb-4">분석 결과를 어떤 형식으로 내보내시겠습니까?</p>
                    
                    <div class="space-y-3">
                        <button onclick="exportToMarkdown()" class="w-full bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 flex items-center justify-center">
                            📝 Markdown (.md) - 문서 편집용
                        </button>
                        
                        <button onclick="exportToPDF()" class="w-full bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 flex items-center justify-center">
                            📄 PDF - 보고서 인쇄용
                        </button>
                        
                        <button onclick="exportToExcel()" class="w-full bg-orange-600 text-white px-4 py-2 rounded hover:bg-orange-700 flex items-center justify-center">
                            📊 Excel (.xlsx) - 데이터 재분석용
                        </button>
                        
                        <button onclick="closeExportModal()" class="w-full bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">
                            취소
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        // 내보내기 모달 닫기
        function closeExportModal() {
            const modal = document.getElementById('exportModal');
            if (modal) {
                modal.remove();
            }
        }
        
        // 분석 초기화
        function resetAnalysis() {
            // 데이터와 결과 초기화
            currentData = null;
            analysisResults = {};
            
            // UI 초기화
            document.getElementById('dropZone').classList.remove('hidden');
            document.getElementById('filePreview').classList.add('hidden');
            document.getElementById('fileInput').value = '';
            document.getElementById('proceedBtn1').disabled = true;
            
            // 각 단계 결과 영역 초기화
            document.getElementById('dataValidation').innerHTML = '';
            document.getElementById('normalityResults').innerHTML = '';
            document.getElementById('homogeneityResults').innerHTML = '';
            document.getElementById('methodRecommendation').innerHTML = '';
            document.getElementById('analysisResults').innerHTML = '';
            
            // 내보내기 버튼 숨기기
            const exportBtn = document.getElementById('exportBtn');
            if (exportBtn) {
                exportBtn.style.display = 'none';
            }
            
            // 1단계로 이동
            moveToStep(1);
        }
        
        // 다크 모드 토글
        const darkModeToggle = document.getElementById('darkModeToggle');
        const sunIcon = document.getElementById('sunIcon');
        const moonIcon = document.getElementById('moonIcon');
        
        // 저장된 테마 불러오기
        const savedTheme = localStorage.getItem('theme') || 'light';
        document.documentElement.setAttribute('data-theme', savedTheme);
        updateThemeIcon(savedTheme);
        
        darkModeToggle?.addEventListener('click', () => {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            
            document.documentElement.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateThemeIcon(newTheme);
        });
        
        function updateThemeIcon(theme) {
            if (theme === 'dark') {
                sunIcon?.classList.remove('hidden');
                moonIcon?.classList.add('hidden');
            } else {
                sunIcon?.classList.add('hidden');
                moonIcon?.classList.remove('hidden');
            }
        }
        
        // 데이터 저장/복구 기능
        function saveProgress() {
            const progressData = {
                currentStep: currentStep,
                currentData: currentData,
                analysisResults: analysisResults,
                autoProgress: autoProgress,
                timestamp: new Date().toISOString()
            };
            
            localStorage.setItem('analysisProgress', JSON.stringify(progressData));
            // 시각적 피드백 제거 - 자동 저장은 조용히 진행
        }
        
        function loadProgress() {
            const saved = localStorage.getItem('analysisProgress');
            if (saved) {
                const progressData = JSON.parse(saved);
                currentStep = progressData.currentStep;
                currentData = progressData.currentData;
                analysisResults = progressData.analysisResults;
                autoProgress = progressData.autoProgress;
                
                // UI 복구
                document.getElementById('autoProgress').checked = autoProgress;
                moveToStep(currentStep);
                
                // 복구 메시지
                const msg = document.createElement('div');
                msg.className = 'fixed bottom-4 right-4 bg-blue-500 text-white px-4 py-2 rounded-lg shadow-lg z-50';
                msg.innerHTML = `이전 세션 복구 (${new Date(progressData.timestamp).toLocaleString()})`;
                document.body.appendChild(msg);
                setTimeout(() => msg.remove(), 3000);
            }
        }
        
        // 진행 상황 내보내기
        // Markdown으로 내보내기
        function exportToMarkdown() {
            closeExportModal();
            
            const date = new Date().toLocaleString('ko-KR');
            const results = analysisResults;
            
            let markdown = `# 통계 분석 보고서\n\n`;
            markdown += `**생성일시**: ${date}\n`;
            markdown += `**플랫폼**: 국립수산과학원 통계 분석 플랫폼\n\n`;
            markdown += `---\n\n`;
            
            // 1. 데이터 요약
            markdown += `## 1. 데이터 요약\n\n`;
            if (currentData) {
                const columns = Object.keys(currentData);
                const rows = currentData[columns[0]]?.length || 0;
                markdown += `- **변수 수**: ${columns.length}개\n`;
                markdown += `- **관측치 수**: ${rows}개\n`;
                markdown += `- **변수 목록**: ${columns.join(', ')}\n\n`;
            }
            
            // 2. 데이터 검증 결과
            if (results.validation) {
                markdown += `## 2. 데이터 검증\n\n`;
                markdown += `- **수치형 변수**: ${results.validation.numericColumns?.join(', ') || '없음'}\n`;
                markdown += `- **범주형 변수**: ${results.validation.groupColumns?.join(', ') || '없음'}\n`;
                markdown += `- **결측치**: ${results.validation.missingValues || 0}개\n`;
                markdown += `- **이상치**: ${results.validation.outliers || 0}개\n\n`;
            }
            
            // 3. 통계적 가정 검정
            if (results.assumptions) {
                markdown += `## 3. 통계적 가정 검정\n\n`;
                
                // 정규성 검정
                if (results.assumptions.normality) {
                    markdown += `### 3.1 정규성 검정\n\n`;
                    markdown += `| 변수 | 검정방법 | 통계량 | p-값 | 결과 |\n`;
                    markdown += `|------|----------|--------|------|------|\n`;
                    
                    results.assumptions.normality.forEach(n => {
                        markdown += `| ${n.variable} | ${n.test} | ${n.statistic?.toFixed(4) || '-'} | ${n.pValue?.toFixed(4) || '-'} | ${n.isNormal ? '정규분포 ✓' : '비정규분포 ✗'} |\n`;
                    });
                    markdown += `\n`;
                }
                
                // 등분산성 검정
                if (results.assumptions.homogeneity) {
                    markdown += `### 3.2 등분산성 검정\n\n`;
                    markdown += `| 변수 | 검정방법 | 통계량 | p-값 | 결과 |\n`;
                    markdown += `|------|----------|--------|------|------|\n`;
                    
                    results.assumptions.homogeneity.forEach(h => {
                        markdown += `| ${h.variable} | ${h.test} | ${h.statistic?.toFixed(4) || '-'} | ${h.pValue?.toFixed(4) || '-'} | ${h.isHomogeneous ? '등분산 ✓' : '이분산 ✗'} |\n`;
                    });
                    markdown += `\n`;
                }
            }
            
            // 4. 분석 방법
            if (results.method) {
                markdown += `## 4. 선택된 분석 방법\n\n`;
                markdown += `- **방법**: ${results.method.name}\n`;
                markdown += `- **선택 이유**: ${results.method.reason}\n\n`;
            }
            
            // 5. 분석 결과
            if (results.final) {
                markdown += `## 5. 통계 분석 결과\n\n`;
                const stats = results.final.statistics;
                
                markdown += `- **검정 통계량**: ${stats.testStatistic?.toFixed(4) || '-'}\n`;
                markdown += `- **p-값**: ${stats.pValue?.toFixed(4) || '-'}\n`;
                markdown += `- **유의수준**: 0.05\n`;
                markdown += `- **결론**: ${stats.pValue < 0.05 ? '**통계적으로 유의함**' : '통계적으로 유의하지 않음'}\n\n`;
                
                // 그룹별 통계
                if (stats.groups) {
                    markdown += `### 5.1 그룹별 기술통계\n\n`;
                    markdown += `| 그룹 | 평균 | 표준편차 | 표본수 |\n`;
                    markdown += `|------|------|----------|--------|\n`;
                    
                    for (const [group, data] of Object.entries(stats.groups)) {
                        markdown += `| ${group} | ${data.mean?.toFixed(3) || '-'} | ${data.std?.toFixed(3) || '-'} | ${data.n || '-'} |\n`;
                    }
                    markdown += `\n`;
                }
                
                // 효과 크기
                if (stats.effectSize) {
                    markdown += `### 5.2 효과 크기\n\n`;
                    markdown += `- **Cohen's d**: ${stats.effectSize.cohensD?.toFixed(3) || '-'}\n`;
                    markdown += `- **해석**: ${stats.effectSize.interpretation || '-'}\n\n`;
                }
            }
            
            // 6. 사후분석
            if (results.postHoc) {
                markdown += `## 6. 사후분석 결과\n\n`;
                markdown += `- **방법**: ${results.postHoc.method}\n\n`;
                
                if (results.postHoc.comparisons) {
                    markdown += `| 비교 | 평균차이 | p-값 | 유의성 |\n`;
                    markdown += `|------|----------|------|--------|\n`;
                    
                    results.postHoc.comparisons.forEach(c => {
                        markdown += `| ${c.group1} vs ${c.group2} | ${c.meanDifference?.toFixed(3) || '-'} | ${c.pValue?.toFixed(4) || '-'} | ${c.significant ? '유의함 *' : '-'} |\n`;
                    });
                }
                markdown += `\n`;
            }
            
            // 7. 권장사항
            markdown += `## 7. 권장사항 및 참고사항\n\n`;
            markdown += `- 본 분석은 자동화된 통계 분석 시스템을 사용하였습니다.\n`;
            markdown += `- 결과 해석 시 전문가의 검토를 권장합니다.\n`;
            markdown += `- 추가 분석이 필요한 경우 원본 데이터를 확인하시기 바랍니다.\n`;
            
            // 파일 다운로드
            const blob = new Blob([markdown], {type: 'text/markdown;charset=utf-8'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `통계분석보고서_${new Date().toISOString().slice(0,10)}.md`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // PDF로 내보내기
        async function exportToPDF() {
            closeExportModal();
            
            // jsPDF가 로드되었는지 확인
            if (typeof window.jspdf === 'undefined') {
                alert('PDF 라이브러리를 로딩 중입니다. 잠시 후 다시 시도해주세요.');
                return;
            }
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('p', 'mm', 'a4');
            
            // 한글 폰트 설정 (기본 폰트는 한글 미지원이므로 영문으로 작성)
            const date = new Date().toLocaleDateString('en-US');
            const results = analysisResults;
            
            // 제목
            doc.setFontSize(20);
            doc.text('Statistical Analysis Report', 105, 20, { align: 'center' });
            
            doc.setFontSize(12);
            doc.text(`Date: ${date}`, 20, 35);
            doc.text('Platform: NIFS Statistical Analysis Platform', 20, 42);
            
            doc.line(20, 45, 190, 45);
            
            let yPos = 55;
            
            // 1. Data Summary
            doc.setFontSize(14);
            doc.text('1. Data Summary', 20, yPos);
            yPos += 10;
            
            if (currentData) {
                const columns = Object.keys(currentData);
                const rows = currentData[columns[0]]?.length || 0;
                
                doc.setFontSize(11);
                doc.text(`- Variables: ${columns.length}`, 25, yPos);
                yPos += 7;
                doc.text(`- Observations: ${rows}`, 25, yPos);
                yPos += 7;
                doc.text(`- Variable names: ${columns.join(', ')}`, 25, yPos);
                yPos += 15;
            }
            
            // 2. Statistical Test Results
            if (results.final) {
                doc.setFontSize(14);
                doc.text('2. Statistical Test Results', 20, yPos);
                yPos += 10;
                
                const stats = results.final.statistics;
                doc.setFontSize(11);
                doc.text(`- Test Method: ${results.method?.name || 'N/A'}`, 25, yPos);
                yPos += 7;
                doc.text(`- Test Statistic: ${stats.testStatistic?.toFixed(4) || 'N/A'}`, 25, yPos);
                yPos += 7;
                doc.text(`- p-value: ${stats.pValue?.toFixed(4) || 'N/A'}`, 25, yPos);
                yPos += 7;
                doc.text(`- Significance Level: 0.05`, 25, yPos);
                yPos += 7;
                
                const conclusion = stats.pValue < 0.05 ? 'Statistically Significant' : 'Not Significant';
                doc.setFont(undefined, 'bold');
                doc.text(`- Conclusion: ${conclusion}`, 25, yPos);
                doc.setFont(undefined, 'normal');
                yPos += 15;
            }
            
            // 3. Group Statistics (if available)
            if (results.final?.statistics?.groups) {
                doc.setFontSize(14);
                doc.text('3. Group Statistics', 20, yPos);
                yPos += 10;
                
                doc.setFontSize(11);
                for (const [group, data] of Object.entries(results.final.statistics.groups)) {
                    doc.text(`${group}: Mean=${data.mean?.toFixed(3)}, SD=${data.std?.toFixed(3)}, N=${data.n}`, 25, yPos);
                    yPos += 7;
                    
                    // 페이지 넘김 체크
                    if (yPos > 270) {
                        doc.addPage();
                        yPos = 20;
                    }
                }
            }
            
            // 저장
            doc.save(`Statistical_Report_${new Date().toISOString().slice(0,10)}.pdf`);
        }
        
        // Excel로 내보내기
        function exportToExcel() {
            closeExportModal();
            
            if (typeof XLSX === 'undefined') {
                alert('Excel 라이브러리를 로딩 중입니다. 잠시 후 다시 시도해주세요.');
                return;
            }
            
            const wb = XLSX.utils.book_new();
            
            // 1. 원본 데이터 시트
            if (currentData) {
                const ws = XLSX.utils.json_to_sheet(
                    Object.keys(currentData[Object.keys(currentData)[0]]).map(i => {
                        const row = {};
                        Object.keys(currentData).forEach(col => {
                            row[col] = currentData[col][i];
                        });
                        return row;
                    })
                );
                XLSX.utils.book_append_sheet(wb, ws, "원본데이터");
            }
            
            // 2. 분석 결과 시트
            const resultsData = [];
            
            if (analysisResults.final) {
                const stats = analysisResults.final.statistics;
                resultsData.push(['통계 분석 결과']);
                resultsData.push(['']);
                resultsData.push(['항목', '값']);
                resultsData.push(['분석 방법', analysisResults.method?.name || '']);
                resultsData.push(['검정 통계량', stats.testStatistic?.toFixed(4) || '']);
                resultsData.push(['p-값', stats.pValue?.toFixed(4) || '']);
                resultsData.push(['유의수준', '0.05']);
                resultsData.push(['결론', stats.pValue < 0.05 ? '유의함' : '유의하지 않음']);
                
                if (stats.groups) {
                    resultsData.push(['']);
                    resultsData.push(['그룹별 통계']);
                    resultsData.push(['그룹', '평균', '표준편차', '표본수']);
                    
                    for (const [group, data] of Object.entries(stats.groups)) {
                        resultsData.push([group, data.mean?.toFixed(3), data.std?.toFixed(3), data.n]);
                    }
                }
            }
            
            const ws2 = XLSX.utils.aoa_to_sheet(resultsData);
            XLSX.utils.book_append_sheet(wb, ws2, "분석결과");
            
            // 파일 저장
            XLSX.writeFile(wb, `통계분석_${new Date().toISOString().slice(0,10)}.xlsx`);
        }
        
        // 진행 상황 가져오기
        function importProgress(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importData = JSON.parse(e.target.result);
                    currentData = importData.data;
                    analysisResults = importData.results;
                    currentStep = importData.metadata.currentStep;
                    autoProgress = importData.settings.autoProgress;
                    
                    // UI 업데이트
                    moveToStep(currentStep);
                    document.getElementById('autoProgress').checked = autoProgress;
                    
                    alert('진행 상황을 성공적으로 불러왔습니다');
                } catch (error) {
                    alert('파일을 읽을 수 없습니다: ' + error.message);
                }
            };
            reader.readAsText(file);
        }
        
        // 비교 분석 기능
        let comparisonDatasets = [];
        
        function addComparisonDataset(name, data) {
            comparisonDatasets.push({
                name: name,
                data: data,
                results: null,
                timestamp: new Date().toISOString()
            });
            
            updateComparisonUI();
        }
        
        function updateComparisonUI() {
            if (comparisonDatasets.length > 1) {
                // 비교 분석 버튼 표시
                const compareBtn = document.getElementById('compareBtn');
                if (!compareBtn) {
                    const btn = document.createElement('button');
                    btn.id = 'compareBtn';
                    btn.className = 'btn-primary mt-4';
                    btn.innerHTML = '📊 데이터셋 비교 분석';
                    btn.onclick = runComparisonAnalysis;
                    document.querySelector('.max-w-7xl').appendChild(btn);
                }
            }
        }
        
        async function runComparisonAnalysis() {
            if (!pyodide) {
                alert('통계 엔진이 아직 준비되지 않았습니다');
                return;
            }
            
            // 비교 분석 모달 표시
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center';
            modal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 rounded-lg p-8 max-w-4xl mx-4 max-h-[80vh] overflow-y-auto">
                    <h2 class="text-2xl font-bold mb-4">📊 데이터셋 비교 분석</h2>
                    <div class="grid grid-cols-2 gap-4">
                        ${comparisonDatasets.map((ds, i) => `
                            <div class="border rounded-lg p-4">
                                <h3 class="font-semibold">${ds.name}</h3>
                                <p class="text-sm text-gray-600">데이터 포인트: ${Object.values(ds.data)[0]?.length || 0}</p>
                                <p class="text-sm text-gray-600">그룹 수: ${Object.keys(ds.data).length}</p>
                            </div>
                        `).join('')}
                    </div>
                    <div id="comparisonResults" class="mt-6">
                        <div class="loading-spinner mx-auto"></div>
                        <p class="text-center mt-2">비교 분석 중...</p>
                    </div>
                    <button onclick="this.parentElement.parentElement.remove()" class="btn-secondary mt-4">
                        닫기
                    </button>
                </div>
            `;
            document.body.appendChild(modal);
            
            // 비교 분석 실행
            setTimeout(async () => {
                const results = await pyodide.runPythonAsync(`
                    import json
                    
                    def compare_datasets(datasets):
                        results = []
                        for ds in datasets:
                            # 기본 통계
                            stats = {}
                            for key, values in ds['data'].items():
                                numeric_vals = [float(v) for v in values if v is not None]
                                if numeric_vals:
                                    stats[key] = {
                                        'mean': np.mean(numeric_vals),
                                        'std': np.std(numeric_vals),
                                        'min': np.min(numeric_vals),
                                        'max': np.max(numeric_vals)
                                    }
                            results.append({
                                'name': ds['name'],
                                'stats': stats
                            })
                        
                        # 데이터셋 간 비교
                        if len(datasets) == 2:
                            # t-test 또는 Mann-Whitney U test
                            pass
                        
                        return json.dumps(results)
                    
                    compare_datasets(${JSON.stringify(comparisonDatasets)})
                `);
                
                const compResults = JSON.parse(results);
                document.getElementById('comparisonResults').innerHTML = `
                    <h3 class="font-semibold mb-3">비교 분석 결과</h3>
                    ${compResults.map(r => `
                        <div class="mb-4">
                            <h4 class="font-medium">${r.name}</h4>
                            ${Object.entries(r.stats).map(([key, stats]) => `
                                <p class="text-sm">
                                    ${key}: 평균=${stats.mean.toFixed(2)}, 
                                    표준편차=${stats.std.toFixed(2)}
                                </p>
                            `).join('')}
                        </div>
                    `).join('')}
                `;
            }, 1000);
        }
        
        // 자동 저장 기능 제거 - 매번 새로 시작하는 것이 더 깔끔함
        
        // 페이지 로드 시 이전 데이터 정리 (깔끔한 시작)
        window.addEventListener('load', () => {
            // 이전 분석 데이터 정리 (매번 새로 시작)
            localStorage.removeItem('analysisProgress');
        });
        
        // 페이지 종료 시 자동 저장 제거 - 매번 깔끔하게 시작
        
        // 추가 분석 함수들
        
        // One-way ANOVA 실행
        async function performOneWayANOVA(method) {
            const pythonCode = `
import numpy as np
from scipy import stats
import json

def one_way_anova(data, factor, dependent):
    """One-way ANOVA 실행"""
    import pandas as pd
    df = pd.DataFrame(data)
    
    # 그룹별 데이터 분리
    groups = {}
    for level in df[factor].unique():
        groups[level] = df[df[factor] == level][dependent].dropna().tolist()
    
    # 각 그룹의 데이터
    group_data = list(groups.values())
    group_names = list(groups.keys())
    
    # One-way ANOVA
    f_stat, p_value = stats.f_oneway(*group_data)
    
    # 기술통계
    group_stats = {}
    for name, data in groups.items():
        group_stats[name] = {
            'mean': float(np.mean(data)),
            'std': float(np.std(data, ddof=1)),
            'n': len(data)
        }
    
    return {
        'f_statistic': float(f_stat),
        'p_value': float(p_value),
        'groups': group_stats,
        'factor': factor,
        'dependent': dependent
    }

result = one_way_anova(${JSON.stringify(currentData)}, '${method.factor}', '${method.dependent}')
result
`;
            
            const pyResult = await pyodide.runPythonAsync(pythonCode);
            const result = pyResult.toJs({dict_converter: Object.fromEntries});
            
            const interpretation = result.p_value < 0.05 ?
                `그룹 간 유의미한 차이가 있습니다 (F=${result.f_statistic.toFixed(3)}, p=${result.p_value.toFixed(4)}).` :
                `그룹 간 유의미한 차이가 없습니다 (F=${result.f_statistic.toFixed(3)}, p=${result.p_value.toFixed(4)}).`;
            
            return {
                test: 'One-way ANOVA',
                type: 'one_way_anova',
                result: result,
                interpretation: interpretation,
                significant: result.p_value < 0.05,
                pValue: result.p_value
            };
        }
        
        // t-test 실행
        async function performTTest(method) {
            const pythonCode = `
import numpy as np
from scipy import stats
import json

def independent_ttest(data, factor, dependent):
    """독립표본 t-test 실행"""
    import pandas as pd
    df = pd.DataFrame(data)
    
    groups = list(df[factor].unique())
    if len(groups) != 2:
        raise ValueError('t-test는 정확히 2개 그룹이 필요합니다')
    
    group1_data = df[df[factor] == groups[0]][dependent].dropna().tolist()
    group2_data = df[df[factor] == groups[1]][dependent].dropna().tolist()
    
    # 독립표본 t-test
    t_stat, p_value = stats.ttest_ind(group1_data, group2_data)
    
    # 등분산 검정
    levene_stat, levene_p = stats.levene(group1_data, group2_data)
    equal_var = levene_p > 0.05
    
    # Welch's t-test (등분산 가정 위반시)
    if not equal_var:
        t_stat, p_value = stats.ttest_ind(group1_data, group2_data, equal_var=False)
    
    return {
        't_statistic': float(t_stat),
        'p_value': float(p_value),
        'equal_variances': equal_var,
        'group1': {'name': groups[0], 'mean': float(np.mean(group1_data)), 'n': len(group1_data)},
        'group2': {'name': groups[1], 'mean': float(np.mean(group2_data)), 'n': len(group2_data)},
        'test_type': 'Welch\\'s t-test' if not equal_var else 'Student\\'s t-test'
    }

result = independent_ttest(${JSON.stringify(currentData)}, '${method.factor}', '${method.dependent}')
result
`;
            
            const pyResult = await pyodide.runPythonAsync(pythonCode);
            const result = pyResult.toJs({dict_converter: Object.fromEntries});
            
            const interpretation = result.p_value < 0.05 ?
                `두 그룹 간 유의미한 차이가 있습니다 (t=${result.t_statistic.toFixed(3)}, p=${result.p_value.toFixed(4)}).` :
                `두 그룹 간 유의미한 차이가 없습니다 (t=${result.t_statistic.toFixed(3)}, p=${result.p_value.toFixed(4)}).`;
            
            return {
                test: result.test_type,
                type: 'ttest',
                result: result,
                interpretation: interpretation,
                significant: result.p_value < 0.05,
                pValue: result.p_value
            };
        }
        
        // 기타 분석들 (간단 구현)
        async function performCPUEAnalysis(method) {
            return {
                test: 'CPUE Analysis',
                type: 'cpue',
                interpretation: 'CPUE 분석 기능은 개발 중입니다. 현재는 기본 통계 분석을 제공합니다.',
                pValue: 0.05
            };
        }
        
        async function performGrowthAnalysis(method) {
            return {
                test: 'Growth Analysis',
                type: 'growth',
                interpretation: '성장 분석 기능은 개발 중입니다. 현재는 기본 통계 분석을 제공합니다.',
                pValue: 0.05
            };
        }
        
        async function performDescriptiveStats(method) {
            const pythonCode = `
import numpy as np
from scipy import stats
import json

def descriptive_stats(data):
    """기술통계 분석"""
    import pandas as pd
    df = pd.DataFrame(data)
    
    # 숫자형 컬럼만 선택
    numeric_cols = df.select_dtypes(include=[np.number]).columns.tolist()
    
    results = {}
    for col in numeric_cols:
        col_data = df[col].dropna()
        results[col] = {
            'count': len(col_data),
            'mean': float(np.mean(col_data)),
            'std': float(np.std(col_data, ddof=1)),
            'min': float(np.min(col_data)),
            'max': float(np.max(col_data)),
            'q25': float(np.percentile(col_data, 25)),
            'median': float(np.percentile(col_data, 50)),
            'q75': float(np.percentile(col_data, 75))
        }
    
    return results

result = descriptive_stats(${JSON.stringify(currentData)})
result
`;
            
            const pyResult = await pyodide.runPythonAsync(pythonCode);
            const result = pyResult.toJs({dict_converter: Object.fromEntries});
            
            return {
                test: 'Descriptive Statistics',
                type: 'descriptive',
                result: result,
                interpretation: `${Object.keys(result).length}개 변수의 기술통계가 계산되었습니다.`,
                pValue: null
            };
        }
    </script>
</body>
</html>