<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>사후검정 분석 테스트</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="p-8 bg-gray-50">
    <div class="max-w-6xl mx-auto">
        <h1 class="text-3xl font-bold mb-6">ANOVA 사후검정 (Post-hoc Tests)</h1>
        
        <!-- 데이터 입력 -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <h2 class="text-xl font-semibold mb-4">1. 데이터 입력</h2>
            <button onclick="loadSampleData()" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600 mb-4">
                샘플 데이터 로드 (3개 그룹)
            </button>
            <div id="dataDisplay" class="bg-gray-50 p-4 rounded font-mono text-sm"></div>
        </div>
        
        <!-- ANOVA 분석 -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <h2 class="text-xl font-semibold mb-4">2. One-way ANOVA</h2>
            <button onclick="performANOVA()" class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600">
                ANOVA 실행
            </button>
            <div id="anovaResults" class="mt-4"></div>
        </div>
        
        <!-- 사후검정 -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <h2 class="text-xl font-semibold mb-4">3. 사후검정 (Post-hoc Tests)</h2>
            <div class="grid grid-cols-2 gap-4 mb-4">
                <button onclick="performTukeyHSD()" class="bg-purple-500 text-white px-4 py-2 rounded hover:bg-purple-600">
                    Tukey HSD (등분산)
                </button>
                <button onclick="performGamesHowell()" class="bg-purple-500 text-white px-4 py-2 rounded hover:bg-purple-600">
                    Games-Howell (이분산)
                </button>
                <button onclick="performBonferroni()" class="bg-indigo-500 text-white px-4 py-2 rounded hover:bg-indigo-600">
                    Bonferroni
                </button>
                <button onclick="performScheffe()" class="bg-indigo-500 text-white px-4 py-2 rounded hover:bg-indigo-600">
                    Scheffé
                </button>
            </div>
            <div id="postHocResults" class="mt-4"></div>
        </div>
        
        <!-- 비모수 사후검정 -->
        <div class="bg-white rounded-lg shadow-md p-6">
            <h2 class="text-xl font-semibold mb-4">4. 비모수 사후검정</h2>
            <div class="grid grid-cols-2 gap-4 mb-4">
                <button onclick="performDunnTest()" class="bg-orange-500 text-white px-4 py-2 rounded hover:bg-orange-600">
                    Dunn's Test
                </button>
                <button onclick="performNemenyiTest()" class="bg-orange-500 text-white px-4 py-2 rounded hover:bg-orange-600">
                    Nemenyi Test
                </button>
            </div>
            <div id="nonParametricResults" class="mt-4"></div>
        </div>
    </div>
    
    <script>
        // 전역 데이터 저장
        let groupData = {};
        let anovaResult = null;
        
        // 샘플 데이터 로드
        function loadSampleData() {
            // 실제 차이가 있는 3개 그룹 데이터
            groupData = {
                'A그룹': [23, 25, 27, 22, 24, 26, 25, 23, 28, 24],
                'B그룹': [31, 33, 35, 30, 32, 34, 33, 31, 36, 32],
                'C그룹': [27, 29, 28, 26, 30, 28, 27, 29, 31, 28]
            };
            
            displayData();
        }
        
        // 데이터 표시
        function displayData() {
            let html = '<h3 class="font-semibold mb-2">입력 데이터</h3>';
            for (const [group, values] of Object.entries(groupData)) {
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                const std = Math.sqrt(values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / (values.length - 1));
                html += `<div class="mb-2">
                    <strong>${group}:</strong> ${values.join(', ')}
                    <span class="text-gray-600 ml-2">(평균: ${mean.toFixed(2)}, 표준편차: ${std.toFixed(2)})</span>
                </div>`;
            }
            document.getElementById('dataDisplay').innerHTML = html;
        }
        
        // One-way ANOVA 수행
        function performANOVA() {
            if (Object.keys(groupData).length < 2) {
                alert('먼저 데이터를 로드하세요.');
                return;
            }
            
            const groups = Object.values(groupData);
            const groupNames = Object.keys(groupData);
            const k = groups.length; // 그룹 수
            const N = groups.reduce((sum, g) => sum + g.length, 0); // 전체 샘플 수
            
            // 전체 평균
            const allValues = groups.flat();
            const grandMean = allValues.reduce((a, b) => a + b, 0) / N;
            
            // SST (Total Sum of Squares)
            const SST = allValues.reduce((sum, val) => sum + Math.pow(val - grandMean, 2), 0);
            
            // SSB (Between Groups Sum of Squares)
            let SSB = 0;
            const groupMeans = {};
            for (let i = 0; i < groups.length; i++) {
                const groupMean = groups[i].reduce((a, b) => a + b, 0) / groups[i].length;
                groupMeans[groupNames[i]] = groupMean;
                SSB += groups[i].length * Math.pow(groupMean - grandMean, 2);
            }
            
            // SSW (Within Groups Sum of Squares)
            const SSW = SST - SSB;
            
            // 자유도
            const dfBetween = k - 1;
            const dfWithin = N - k;
            const dfTotal = N - 1;
            
            // Mean Squares
            const MSB = SSB / dfBetween;
            const MSW = SSW / dfWithin;
            
            // F-statistic
            const F = MSB / MSW;
            
            // p-value (근사값 - 실제로는 F-분포 필요)
            const pValue = F > 3 ? 0.01 : F > 2 ? 0.05 : 0.15;
            
            anovaResult = {
                groupMeans,
                grandMean,
                SST, SSB, SSW,
                dfBetween, dfWithin, dfTotal,
                MSB, MSW,
                F,
                pValue,
                k,
                N
            };
            
            // 결과 표시
            const resultsDiv = document.getElementById('anovaResults');
            resultsDiv.innerHTML = `
                <h3 class="font-semibold mb-2">ANOVA 결과</h3>
                <table class="w-full border-collapse">
                    <thead>
                        <tr class="border-b">
                            <th class="text-left p-2">Source</th>
                            <th class="text-right p-2">SS</th>
                            <th class="text-right p-2">df</th>
                            <th class="text-right p-2">MS</th>
                            <th class="text-right p-2">F</th>
                            <th class="text-right p-2">p-value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr class="border-b">
                            <td class="p-2">Between Groups</td>
                            <td class="text-right p-2">${SSB.toFixed(2)}</td>
                            <td class="text-right p-2">${dfBetween}</td>
                            <td class="text-right p-2">${MSB.toFixed(2)}</td>
                            <td class="text-right p-2">${F.toFixed(3)}</td>
                            <td class="text-right p-2">${pValue < 0.001 ? '<0.001' : pValue.toFixed(3)}</td>
                        </tr>
                        <tr class="border-b">
                            <td class="p-2">Within Groups</td>
                            <td class="text-right p-2">${SSW.toFixed(2)}</td>
                            <td class="text-right p-2">${dfWithin}</td>
                            <td class="text-right p-2">${MSW.toFixed(2)}</td>
                            <td class="text-right p-2">-</td>
                            <td class="text-right p-2">-</td>
                        </tr>
                        <tr>
                            <td class="p-2 font-semibold">Total</td>
                            <td class="text-right p-2">${SST.toFixed(2)}</td>
                            <td class="text-right p-2">${dfTotal}</td>
                            <td class="text-right p-2">-</td>
                            <td class="text-right p-2">-</td>
                            <td class="text-right p-2">-</td>
                        </tr>
                    </tbody>
                </table>
                <div class="mt-3 p-3 ${pValue < 0.05 ? 'bg-green-50 text-green-800' : 'bg-gray-50'}">
                    <strong>결론:</strong> ${pValue < 0.05 ? 
                        '그룹 간 유의한 차이가 있습니다. 사후검정이 필요합니다.' : 
                        '그룹 간 유의한 차이가 없습니다.'}
                </div>
            `;
        }
        
        // Tukey HSD 사후검정
        function performTukeyHSD() {
            if (!anovaResult) {
                alert('먼저 ANOVA를 실행하세요.');
                return;
            }
            
            const groupNames = Object.keys(groupData);
            const comparisons = [];
            
            // Studentized range statistic q (근사값)
            const q_critical = 3.77; // α=0.05, k=3, df=27 근사값
            
            for (let i = 0; i < groupNames.length; i++) {
                for (let j = i + 1; j < groupNames.length; j++) {
                    const group1 = groupNames[i];
                    const group2 = groupNames[j];
                    const mean1 = anovaResult.groupMeans[group1];
                    const mean2 = anovaResult.groupMeans[group2];
                    const n1 = groupData[group1].length;
                    const n2 = groupData[group2].length;
                    
                    // 평균 차이
                    const meanDiff = Math.abs(mean1 - mean2);
                    
                    // 표준 오차
                    const SE = Math.sqrt(anovaResult.MSW * (1/n1 + 1/n2) / 2);
                    
                    // HSD (Honestly Significant Difference)
                    const HSD = q_critical * SE;
                    
                    // 신뢰구간
                    const CI_lower = meanDiff - HSD;
                    const CI_upper = meanDiff + HSD;
                    
                    // 유의성 판정
                    const significant = meanDiff > HSD;
                    
                    comparisons.push({
                        group1,
                        group2,
                        meanDiff,
                        SE,
                        HSD,
                        CI: [CI_lower, CI_upper],
                        significant
                    });
                }
            }
            
            displayPostHocResults('Tukey HSD', comparisons);
        }
        
        // Games-Howell 사후검정 (이분산 가정)
        function performGamesHowell() {
            if (!anovaResult) {
                alert('먼저 ANOVA를 실행하세요.');
                return;
            }
            
            const groupNames = Object.keys(groupData);
            const comparisons = [];
            
            for (let i = 0; i < groupNames.length; i++) {
                for (let j = i + 1; j < groupNames.length; j++) {
                    const group1 = groupNames[i];
                    const group2 = groupNames[j];
                    const data1 = groupData[group1];
                    const data2 = groupData[group2];
                    
                    const mean1 = anovaResult.groupMeans[group1];
                    const mean2 = anovaResult.groupMeans[group2];
                    const n1 = data1.length;
                    const n2 = data2.length;
                    
                    // 각 그룹의 분산
                    const var1 = data1.reduce((sum, x) => sum + Math.pow(x - mean1, 2), 0) / (n1 - 1);
                    const var2 = data2.reduce((sum, x) => sum + Math.pow(x - mean2, 2), 0) / (n2 - 1);
                    
                    // 평균 차이
                    const meanDiff = Math.abs(mean1 - mean2);
                    
                    // 표준 오차 (Welch 방식)
                    const SE = Math.sqrt(var1/n1 + var2/n2);
                    
                    // 자유도 (Welch-Satterthwaite)
                    const df = Math.pow(var1/n1 + var2/n2, 2) / 
                              (Math.pow(var1/n1, 2)/(n1-1) + Math.pow(var2/n2, 2)/(n2-1));
                    
                    // t-critical (근사값)
                    const t_critical = 2.05; // df≈18, α=0.05
                    
                    // 신뢰구간
                    const CI_lower = meanDiff - t_critical * SE;
                    const CI_upper = meanDiff + t_critical * SE;
                    
                    // 유의성 판정
                    const significant = CI_lower > 0;
                    
                    comparisons.push({
                        group1,
                        group2,
                        meanDiff,
                        SE,
                        df: df.toFixed(1),
                        CI: [CI_lower, CI_upper],
                        significant
                    });
                }
            }
            
            displayPostHocResults('Games-Howell', comparisons);
        }
        
        // Bonferroni 보정
        function performBonferroni() {
            if (!anovaResult) {
                alert('먼저 ANOVA를 실행하세요.');
                return;
            }
            
            const groupNames = Object.keys(groupData);
            const comparisons = [];
            const numComparisons = (groupNames.length * (groupNames.length - 1)) / 2;
            const adjustedAlpha = 0.05 / numComparisons;
            
            for (let i = 0; i < groupNames.length; i++) {
                for (let j = i + 1; j < groupNames.length; j++) {
                    const group1 = groupNames[i];
                    const group2 = groupNames[j];
                    const mean1 = anovaResult.groupMeans[group1];
                    const mean2 = anovaResult.groupMeans[group2];
                    const n1 = groupData[group1].length;
                    const n2 = groupData[group2].length;
                    
                    // t-test 수행
                    const meanDiff = Math.abs(mean1 - mean2);
                    const SE = Math.sqrt(anovaResult.MSW * (1/n1 + 1/n2));
                    const t_stat = meanDiff / SE;
                    
                    // t-critical (Bonferroni 보정)
                    const t_critical = 2.73; // df=27, α=0.05/3=0.0167
                    
                    // 신뢰구간
                    const CI_lower = meanDiff - t_critical * SE;
                    const CI_upper = meanDiff + t_critical * SE;
                    
                    // p-value (근사)
                    const pValue = t_stat > 3 ? 0.001 : t_stat > 2 ? 0.05 : 0.15;
                    const adjustedP = Math.min(pValue * numComparisons, 1);
                    
                    comparisons.push({
                        group1,
                        group2,
                        meanDiff,
                        SE,
                        t_stat,
                        pValue: adjustedP,
                        CI: [CI_lower, CI_upper],
                        significant: adjustedP < 0.05
                    });
                }
            }
            
            displayPostHocResults('Bonferroni', comparisons);
        }
        
        // Scheffé 검정
        function performScheffe() {
            if (!anovaResult) {
                alert('먼저 ANOVA를 실행하세요.');
                return;
            }
            
            const groupNames = Object.keys(groupData);
            const comparisons = [];
            
            // F-critical
            const F_critical = 3.35; // α=0.05, df1=2, df2=27
            
            for (let i = 0; i < groupNames.length; i++) {
                for (let j = i + 1; j < groupNames.length; j++) {
                    const group1 = groupNames[i];
                    const group2 = groupNames[j];
                    const mean1 = anovaResult.groupMeans[group1];
                    const mean2 = anovaResult.groupMeans[group2];
                    const n1 = groupData[group1].length;
                    const n2 = groupData[group2].length;
                    
                    const meanDiff = Math.abs(mean1 - mean2);
                    const SE = Math.sqrt(anovaResult.MSW * (1/n1 + 1/n2));
                    
                    // Scheffé critical value
                    const S = Math.sqrt((anovaResult.k - 1) * F_critical) * SE;
                    
                    // 신뢰구간
                    const CI_lower = meanDiff - S;
                    const CI_upper = meanDiff + S;
                    
                    comparisons.push({
                        group1,
                        group2,
                        meanDiff,
                        SE,
                        S,
                        CI: [CI_lower, CI_upper],
                        significant: meanDiff > S
                    });
                }
            }
            
            displayPostHocResults('Scheffé', comparisons);
        }
        
        // Dunn's Test (비모수)
        function performDunnTest() {
            if (Object.keys(groupData).length < 2) {
                alert('먼저 데이터를 로드하세요.');
                return;
            }
            
            const groupNames = Object.keys(groupData);
            const allData = [];
            const groupLabels = [];
            
            // 모든 데이터와 그룹 레이블 수집
            for (const [group, values] of Object.entries(groupData)) {
                values.forEach(val => {
                    allData.push(val);
                    groupLabels.push(group);
                });
            }
            
            // 순위 계산
            const ranks = getRanks(allData);
            
            // 각 그룹의 평균 순위
            const meanRanks = {};
            for (const group of groupNames) {
                const groupIndices = groupLabels.map((g, i) => g === group ? i : -1).filter(i => i >= 0);
                const groupRanks = groupIndices.map(i => ranks[i]);
                meanRanks[group] = groupRanks.reduce((a, b) => a + b, 0) / groupRanks.length;
            }
            
            const comparisons = [];
            const N = allData.length;
            const numComparisons = (groupNames.length * (groupNames.length - 1)) / 2;
            
            for (let i = 0; i < groupNames.length; i++) {
                for (let j = i + 1; j < groupNames.length; j++) {
                    const group1 = groupNames[i];
                    const group2 = groupNames[j];
                    const n1 = groupData[group1].length;
                    const n2 = groupData[group2].length;
                    
                    const rankDiff = Math.abs(meanRanks[group1] - meanRanks[group2]);
                    
                    // Standard Error
                    const SE = Math.sqrt((N * (N + 1) / 12) * (1/n1 + 1/n2));
                    
                    // z-statistic
                    const z = rankDiff / SE;
                    
                    // Bonferroni 보정된 임계값
                    const z_critical = 2.39; // α=0.05/3
                    
                    comparisons.push({
                        group1,
                        group2,
                        rankDiff,
                        meanRank1: meanRanks[group1],
                        meanRank2: meanRanks[group2],
                        z,
                        significant: z > z_critical
                    });
                }
            }
            
            displayNonParametricResults('Dunn Test', comparisons);
        }
        
        // Nemenyi Test
        function performNemenyiTest() {
            if (Object.keys(groupData).length < 2) {
                alert('먼저 데이터를 로드하세요.');
                return;
            }
            
            const groupNames = Object.keys(groupData);
            const allData = [];
            const groupLabels = [];
            
            // 모든 데이터와 그룹 레이블 수집
            for (const [group, values] of Object.entries(groupData)) {
                values.forEach(val => {
                    allData.push(val);
                    groupLabels.push(group);
                });
            }
            
            // 순위 계산
            const ranks = getRanks(allData);
            
            // 각 그룹의 평균 순위
            const meanRanks = {};
            for (const group of groupNames) {
                const groupIndices = groupLabels.map((g, i) => g === group ? i : -1).filter(i => i >= 0);
                const groupRanks = groupIndices.map(i => ranks[i]);
                meanRanks[group] = groupRanks.reduce((a, b) => a + b, 0) / groupRanks.length;
            }
            
            const comparisons = [];
            const k = groupNames.length;
            const N = allData.length;
            const n = N / k; // 균형 설계 가정
            
            // q-critical (Studentized range)
            const q_critical = 3.31; // α=0.05, k=3
            
            for (let i = 0; i < groupNames.length; i++) {
                for (let j = i + 1; j < groupNames.length; j++) {
                    const group1 = groupNames[i];
                    const group2 = groupNames[j];
                    
                    const rankDiff = Math.abs(meanRanks[group1] - meanRanks[group2]);
                    
                    // Critical difference
                    const CD = q_critical * Math.sqrt((k * (k + 1)) / (12 * n));
                    
                    comparisons.push({
                        group1,
                        group2,
                        rankDiff,
                        meanRank1: meanRanks[group1],
                        meanRank2: meanRanks[group2],
                        CD,
                        significant: rankDiff > CD
                    });
                }
            }
            
            displayNonParametricResults('Nemenyi Test', comparisons);
        }
        
        // 순위 계산 함수
        function getRanks(data) {
            const sorted = data.map((val, idx) => ({val, idx})).sort((a, b) => a.val - b.val);
            const ranks = new Array(data.length);
            
            let i = 0;
            while (i < sorted.length) {
                let j = i;
                while (j < sorted.length && sorted[j].val === sorted[i].val) j++;
                
                const avgRank = (i + j + 1) / 2;
                for (let k = i; k < j; k++) {
                    ranks[sorted[k].idx] = avgRank;
                }
                i = j;
            }
            
            return ranks;
        }
        
        // 사후검정 결과 표시
        function displayPostHocResults(method, comparisons) {
            let html = `<h3 class="font-semibold mb-3">${method} 결과</h3>`;
            html += `<table class="w-full border-collapse text-sm">
                <thead>
                    <tr class="border-b bg-gray-50">
                        <th class="text-left p-2">비교</th>
                        <th class="text-right p-2">평균 차이</th>
                        <th class="text-right p-2">표준오차</th>
                        <th class="text-right p-2">95% CI</th>
                        <th class="text-center p-2">유의성</th>
                    </tr>
                </thead>
                <tbody>`;
            
            for (const comp of comparisons) {
                const significant = comp.significant;
                html += `
                    <tr class="border-b ${significant ? 'bg-green-50' : ''}">
                        <td class="p-2">${comp.group1} vs ${comp.group2}</td>
                        <td class="text-right p-2">${comp.meanDiff.toFixed(3)}</td>
                        <td class="text-right p-2">${comp.SE ? comp.SE.toFixed(3) : '-'}</td>
                        <td class="text-right p-2">[${comp.CI[0].toFixed(2)}, ${comp.CI[1].toFixed(2)}]</td>
                        <td class="text-center p-2">
                            ${significant ? 
                                '<span class="text-green-600 font-semibold">유의함 *</span>' : 
                                '<span class="text-gray-500">유의하지 않음</span>'}
                        </td>
                    </tr>`;
            }
            
            html += '</tbody></table>';
            
            // 유의한 쌍 요약
            const significantPairs = comparisons.filter(c => c.significant);
            if (significantPairs.length > 0) {
                html += `<div class="mt-3 p-3 bg-green-50 rounded">
                    <strong>유의한 차이가 있는 그룹 쌍:</strong><br>`;
                for (const pair of significantPairs) {
                    html += `• ${pair.group1} ≠ ${pair.group2}<br>`;
                }
                html += '</div>';
            }
            
            document.getElementById('postHocResults').innerHTML = html;
        }
        
        // 비모수 사후검정 결과 표시
        function displayNonParametricResults(method, comparisons) {
            let html = `<h3 class="font-semibold mb-3">${method} 결과</h3>`;
            html += `<table class="w-full border-collapse text-sm">
                <thead>
                    <tr class="border-b bg-gray-50">
                        <th class="text-left p-2">비교</th>
                        <th class="text-right p-2">평균순위 1</th>
                        <th class="text-right p-2">평균순위 2</th>
                        <th class="text-right p-2">순위 차이</th>
                        <th class="text-center p-2">유의성</th>
                    </tr>
                </thead>
                <tbody>`;
            
            for (const comp of comparisons) {
                const significant = comp.significant;
                html += `
                    <tr class="border-b ${significant ? 'bg-orange-50' : ''}">
                        <td class="p-2">${comp.group1} vs ${comp.group2}</td>
                        <td class="text-right p-2">${comp.meanRank1.toFixed(2)}</td>
                        <td class="text-right p-2">${comp.meanRank2.toFixed(2)}</td>
                        <td class="text-right p-2">${comp.rankDiff.toFixed(2)}</td>
                        <td class="text-center p-2">
                            ${significant ? 
                                '<span class="text-orange-600 font-semibold">유의함 *</span>' : 
                                '<span class="text-gray-500">유의하지 않음</span>'}
                        </td>
                    </tr>`;
            }
            
            html += '</tbody></table>';
            
            // 유의한 쌍 요약
            const significantPairs = comparisons.filter(c => c.significant);
            if (significantPairs.length > 0) {
                html += `<div class="mt-3 p-3 bg-orange-50 rounded">
                    <strong>유의한 차이가 있는 그룹 쌍:</strong><br>`;
                for (const pair of significantPairs) {
                    html += `• ${pair.group1} ≠ ${pair.group2}<br>`;
                }
                html += '</div>';
            }
            
            document.getElementById('nonParametricResults').innerHTML = html;
        }
    </script>
</body>
</html>